{
	"status": "ok",
	"feed": {
		"url": "https://medium.com/feed/@leticia-mirelly",
		"title": "Stories by Leticia Mirelly ϟ on Medium",
		"link": "https://medium.com/@leticia-mirelly?source=rss-7deace8b3a8e------2",
		"author": "",
		"description": "Stories by Leticia Mirelly ϟ on Medium",
		"image": "https://cdn-images-1.medium.com/fit/c/150/150/1*B_p9l2m61TLynuXPBGv-qw.jpeg"
	},
	"items": [
		{
			"title": "Construa uma vez, escale por anos — Aplicações front-end que nascem para durar.",
			"pubDate": "2024-07-06 16:17:11",
			"link": "https://leticia-mirelly.medium.com/construa-uma-vez-escale-por-anos-aplica%C3%A7%C3%B5es-front-end-que-nascem-para-durar-1c9d63242d21?source=rss-7deace8b3a8e------2",
			"guid": "https://medium.com/p/1c9d63242d21",
			"author": "Leticia Mirelly ϟ",
			"thumbnail": "",
			"description": "\n<h3>Construa uma vez, escale por anos — Aplicações front-end que nascem para durar.</h3>\n<a href=\"https://medium.com/media/e6590a4ef3722310fdbf785bde4228c5/href\">https://medium.com/media/e6590a4ef3722310fdbf785bde4228c5/href</a><p>Muitas decisões de negócios ainda priorizam a velocidade de entrega em detrimento da qualidade do desenvolvimento de software, resultando em consequências desastrosas. Dentre os exemplos mais recentes, em 2022, <a href=\"https://www.nytimes.com/2022/12/31/opinion/southwest-airlines-computers.html\">o sistema de agendamento de tripulações da Southwest Airlines</a> não conseguiu lidar com interrupções inesperadas no clima de inverno, levando a muitos cancelamentos de voos e perdas financeiras de aproximadamente 410 milhões de dólares. Outro exemplo é o dos voos Lion Air 610 e Ethiopian Airlines 302, ambos envolvendo aeronaves <a href=\"https://www.rollingstone.com/culture/culture-features/boeing-737-max-disasters-timeline-1235007089/\">Boeing 737 Max</a>, que tiveram parte do problema atribuída a falhas no software do sistema de controle de voo (MCAS) e na documentação.</p>\n<h4>As perguntas que tentarei responder são: Como evidenciar o impacto comercial e financeiro na performance evolutiva de uma aplicação a medida que ela cresce e quais as pontas gerir para não cair no dilema das “<a href=\"https://pt.wikipedia.org/wiki/Teoria_das_janelas_quebradas\">janelas quebradas</a>”.</h4>\n<p>Esse é um tema pretensioso, eu sei. Como desenvolvedora já trabalhei em alguns projetos legados, projetos com ciclos de vida enormes e fui “mãe” de outros, sempre questionei a fundo sobre o que aquela aplicação viria a se tornar a nível de escopo, entretanto essa é sempre uma grande variável que custa a ser mensurada. Acredito fazer sentido responder algo pretensioso assim com um punhado de referências externas e pessoais a fim de documentar estudos e experiências.</p>\n<p><em>Algumas palavras preferi manter em Inglês ao invés de traduzi-las, acredito ser mais proveitoso e eficaz manter como são comumente conhecidas.</em></p>\n<p>Com base no estudo <a href=\"https://arxiv.org/abs/2203.04374\">Code Red: The Business Impact of Code Quality</a>, 39 bases de códigos de produção foram analisados com 30.737 arquivos se baseando na métrica de Code Health da CodeScene como um proxy para qualidade de código considerando a análise de código-fonte, mineração de controle de versão e informações de emissão do Jira foi percebido que código de baixa qualidade contém 15 vezes mais defeitos do que o código de alta qualidade e códigos de baixa qualidade leva em média 124% mais tempo de desenvolvimento. O estudo evidencia ainda que até 42% do tempo dos desenvolvedores é desperdiçado lidando com dívidas técnicas, custando uma média de US$ 85 bilhões por ano. Há uma ponte a ser construída entre o time que realiza a entrega e o time comercial, com 15x menos defeitos e com mais previsibilidade do tempo de desenvolvimento e entrega, a vantagem competitiva de produzir código de qualidade de forma sustentável a longo prazo e com curto time-to-market torna-se clara.</p>\n<p>Infelizmente essa ainda não é uma visão amplamente abraçada pela área de negócio porque muitas vezes não há clareza de benefícios quantificáveis em pagar por refatorações por isso os gestores não concedem o orçamento e prioridade necessárias e acabam negociando as entregas levando em conta o curto prazo muitas vezes chegando no viés da tomada de decisão <em>desconto hiperbólico</em>, onde seus eus futuros lidam com as consequências de escolhas que prefeririam não te-las feito.</p>\n<h3><strong>KPIs da qualidade de software: idiotas da objetividade?</strong></h3>\n<p>Embora existam muitas pesquisas concentradas em nortear a qualidade de software não se pode declarar a mesma solução para todas as aplicações, entretanto podemos usar ferramentas e métodos tangíveis. Essas ferramentas são o começo, e não o fim, de como tangibilizar e negociar débitos técnicos com os gestores.</p>\n<h4>Gerenciar a Dívida técnica</h4>\n<a href=\"https://medium.com/media/523d0736ba1ed8bea0818da53353b981/href\">https://medium.com/media/523d0736ba1ed8bea0818da53353b981/href</a><p>A teoria teoria das janelas quebradas, emprestada da criminologia e aplicada no contexto do desenvolvimento de software (William Levén, <a href=\"https://arxiv.org/pdf/2209.01549\">2023</a> ), trata da relação causal entre a quantidade de débitos técnicos de uma aplicação e a propensão dos desenvolvedores inserirem novos débitos técnicos à medida que a aplicação cresce. Avaliando fatores psicológicos, o comportamento é moldado por uma norma descritiva, onde o comportamento torna-se ser aceitável. Dentre alguns insights alarmantes está a ligação entre DT e a propensão à vulnerabilidade da aplicação incluindo riscos de segurança.</p>\n<p><strong>Tipos de dívida técnica:</strong></p>\n<ul>\n<li>\n<strong>Qualidade do código: </strong>Baixa manutenibilidade, padrões de código inexistentes, mal projetado e muito complexo.</li>\n<li><strong>Baixa cobertura de código e de teste automatizado.</strong></li>\n<li><strong>Bibliotecas e/ou ferramentas desatualizadas/legadas.</strong></li>\n<li><strong>Arquitetura errada ou inexistente.</strong></li>\n<li><strong>Falta de documentação.</strong></li>\n<li><strong>Defeitos/Bugs.</strong></li>\n<li><strong>Entre outros como por exemplo processo manual de CI/CD.</strong></li>\n</ul>\n<p>Para gerenciar eficazmente há algumas etapas como: 1) <strong>identificar as dívidas,</strong> 2) <strong>Torna-las visíveis,</strong> 3) <strong>Implementar mudanças e mitigar os efeitos da dívida.</strong></p>\n<h4><strong>Dando nome às dívidas técnicas</strong></h4>\n<p>De forma prática, há algumas ferramentas de analise automática parcial do código como SonarQube que identifica violações de práticas de codificação e calcula o custo de refatoração de cada dívida. Há ainda dívidas que não são encontradas por ferramentas de analise automatizada mas são conhecidas pelo time de desenvolvimento, é aconselhável mante-las juntamente com dívidas fornecidas por uma ferramenta em um backlog técnico com a descrição do que deverá ser feito e estimativa para resolver.</p>\n<h4><strong>Mapa de débitos técnicos</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*QLDIMgUxwMsz6545GWF4Qg.jpeg\"></figure><p>Esse mapa foi tirado do <a href=\"https://blog.thepete.net/blog/2020/12/01/tech-debt-walls/\">artigo publicado por Pete Hogson </a>, onde as dívidas são colocadas em duas dimensões de <strong>custo</strong> e <strong>valor</strong>. Em suas palavras, Os problemas na área inferior esquerda do muro são “vitórias rápidas” — o tipo de cortesia que você pode receber se quiser limpar um pouco o acampamento em uma tarde tranquila de sexta-feira. Problemas na área superior esquerda do muro são “fáceis de resolver” — trabalho de baixo custo e alto valor que deve ser resolvido em breve. Por outro lado, problemas na área inferior direita do quadro são os itens “não”. O investimento simplesmente não vale a pena quando se trata desses problemas. O restante do muro contém “investimentos valiosos” — itens de dívida que provavelmente fornecerão um bom retorno sobre o investimento, mas também são substanciais o suficiente para exigir negociação com outras partes interessadas para serem priorizados.</p>\n<h4><strong>O que fazer com essas informações?</strong></h4>\n<p><a href=\"https://www.computer.org/\">Frank Buscgmann cita 3 estratégias:</a></p>\n<ul>\n<li>\n<strong>Pague a dívida: </strong>Refatorar ou substituir o código.</li>\n<li>\n<strong>Conversão de dívida: </strong>Substitua a solução atual por uma solução “boa, mas não perfeita”.</li>\n<li>\n<strong>Pague apenas os juros: </strong>Viva com o código, porque a refatoração é mais cara do que trabalhar com o código não muito correto.</li>\n</ul>\n<blockquote>\n<strong><em>A refatoração substancial é sempre uma decisão de negócios(Wolff, </em></strong><a href=\"https://www.infoq.com/articles/managing-technical-debt/\"><strong><em>2013</em></strong></a><strong><em>)</em></strong>\n</blockquote>\n<h4>Modelo de criação de valor</h4>\n<p>Uma analise aprofundada sobre o retorno do investimento em esforços de refatoração é dada no modelo de criação de valor (<a href=\"https://arxiv.org/html/2401.13407v1#abstract\">2024, </a>Markus Borg) e SPACE framework que mensura a <strong>capacidade</strong> e <strong>eficiência</strong> do time de desenvolvimento. O modelo de criação de valor concentra-se em modelos de regressão para identificar a relação entre Code Health e duas variáveis que dependem entre si: 1) número médio de defeitos e 2) tempo médio de Desvio, evidenciando como retorno da analise o impacto de mudanças relativas na qualidade do código-fonte.</p>\n<p><strong>Capacidade</strong> máxima que a organização pode alcançar em condições ideais. Maior capacidade == mais tempo de codificação;</p>\n<p><strong>Eficiência</strong> é a capacidade convertida em valor real. Maior eficiência menos interrupção.</p>\n<p><strong>𝑢</strong> = <strong>fração de trabalho não planejado</strong></p>\n<p>Eficiência = (1 — <strong>𝑢</strong>)</p>\n<blockquote>v = c × ( 1 − 𝑢 )</blockquote>\n<p>Considera-se também duas proporcionalidades: A primeira é que <em>a capacidade é inversamente proporcional ao Time-in-Dev.</em></p>\n<blockquote>Quanto mais os desenvolvedores trabalham na implementação de uma resolução, mais recursos são amarrados para lidar com ela. Esses recursos poderiam, em vez disso, ter sido alocados para o desenvolvimento de novos recursos que contribuem diretamente para a capacidade de desenvolvimento.</blockquote>\n<p>E em segundo lugar,<em> </em><strong><em>a fração de trabalho não planejado é proporcional ao número de defeitos.</em></strong></p>\n<p>Embora tenha se verificado uma não linearidade total entre Code Health e criação de valor os resultados da pesquisa sugerem que:</p>\n<ul>\n<li>As funções técnicas devem comunicar melhor os benefícios aos níveis executivos para informar as decisões estratégicas de refatoração.</li>\n<li>Evitar diligentemente cheiros de código em arquivos onde a taxa de juros sobre a dívida técnica é alta, ou seja, arquivos com rotatividade substancial.</li>\n<li>Os desenvolvedores resolvem problemas rapidamente — e possivelmente de forma imprudente — se a qualidade do código já for péssima.</li>\n</ul>\n<h3>Mais afundo — Amarrando as pontas</h3>\n<p><em>Não pretendo aprofundar na escolha da stack, poderia escrever um artigo somente sobre isso se for desejável, me deixe saber nos comentários.</em></p>\n<blockquote>if you’re afraid to change something it is clearly poorly designed.<br> — Martin Fowler</blockquote>\n<h4>High-level architecture</h4>\n<p>Arquitetura é a forma como as unidades da aplicação interagem entre si, aqui a preocupação é mais a nível estrutural do que a detalhes de implementação e/ou tecnologias de suporte. A arquitetura é guiada pelo domínio e casos de uso.</p>\n<p>Resolver questões complexas na construção de aplicações front-end tem se tornado mais simples mas não mais fácil, isso porque as arquiteturas mudaram muito nos últimos 30 anos à medida que o clássico Model View Control (MVC) evoluía para dar entrada à novas estruturas mais modernas. Curioso perceber que mesmo as estruturas mais atuais foram construídas em estruturas já existentes adicionando melhorias continuas.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*tao7a30JsPeaYv01ijFhTg.png\"><figcaption>Imagem do livro front-end reactive architectures</figcaption></figure><p><em>De antemão, não há razões determinísticas que orientem a arquitetura por um viés padrão à todas, nenhuma arquitetura é boa em si mesmo, o mesmo serve para a escolha da stack, a mais “hypada” não deveria ser escolhida por este motivo também, a escolha se baseia na necessidade do produto e do negócio.</em></p>\n<p>Na prática, representar os requisitos do software são de maior peso na balança, eles podem mudar todo o cenário, um exemplo clássico é a <a href=\"https://gustafnk.github.io/microservice-websites/\">IKEA</a> que devido ao contexto do produto decidiram implementar 2 técnicas: 1) Fragmentos autocontidos (SCS) em uma arquitetura micro front-end que atende a demandas de equipes diferentes com funcionalidades compartilhadas levando a um maior reaproveitamento do esforço de desenvolvimento e entregando somente o que cada fragmento precisa como CSS e JS, e 2) Edge Side Includes (ESI) que entrega dinamicamente para cada fragmento o que é necessário quando solicitado.</p>\n<p>É comum a separação de responsabilidade por camadas no front-end e, também, no backend, isso porque os atores da aplicação possuem objetivos diferentes, ( Não confunda isso com estrutura de pastas ) as camadas nesse nível representam as partes independentes da aplicação como por exemplo a camada de entrada e infraestrutura cada uma com seu objetivo.</p>\n<p><strong>Padrões arquiteturais amplos</strong></p>\n<p><em>First thing: Design Pattern ≠ Arquitetura</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/981/1*vfxVbZCaVvIhp8H333TEJQ.png\"><figcaption><a href=\"https://leanylabs.com/blog/micro-frontends-overview/\">https://leanylabs.com/blog/micro-frontends-overview/</a></figcaption></figure><p><strong>Arquitetura Monolítica</strong></p>\n<p>Abordagem mais tradicional onde todos os componentes são integrados em uma única base de código. Este modelo simplifica o desenvolvimento inicial e o deployment, mas pode levar a problemas de escalabilidade e manutenção à medida que a aplicação cresce. Modificações em uma pequena parte do sistema podem exigir a recompilação e redeployment de toda a aplicação.</p>\n<p><strong>Arquitetura Micro front-end</strong></p>\n<p>Aplica os princípios de microserviços ao front-end, onde a interface do usuário é dividida em componentes menores e independentes. Cada componente é responsável por uma parte específica da interface e pode ser desenvolvido, implantado e atualizado de forma independente. Esta abordagem permite uma maior flexibilidade e escalabilidade no desenvolvimento de interfaces complexas.</p>\n<p>Há algumas escolhas estratégicas de <strong><em>como</em></strong> todas as partes da aplicação irá conversar, além disso, <strong><em>onde</em></strong> será renderizada (cliente/servidor/isomórfico — Podem incluir hidratação parcial e progressiva dando mais poderes a aplicação e não sobrecarregando o cliente), <strong><em>quando</em></strong> será integrada (estático/dinâmico) e <strong><em>o que</em></strong> será integrado.</p>\n<h4><strong>State management</strong></h4>\n<p>Manter uma única fonte de verdade é uma das estratégias da <strong>camada de estado da aplicação</strong>, não há alterações diretas na camada <strong>view</strong> e sim dispatchs para um estado central que modifica a fonte, isso assegura que todos os observadores estejam alinhados. Essa camada não esta diretamente conectada ao uso de bibliotecas como Redux, Vuex ou NgRx store e sim a uma estratégia de envio de eventos a um armazenador de estado.</p>\n<h4><strong>Gerenciamento de versão de dependências</strong></h4>\n<p>Talvez essa seja a ponta mais subestimada. No planejamento dos ciclos de entrega quantas vezes se fala em separar tempo + esforço para atualizar o framework/biblioteca usada na construção da aplicação? Ou de bibliotecas de suporte? Considere que anualmente novas majors release são lançadas e a versão que seu software usa muitas vezes sequer recebe suporte pela equipe dona da ferramenta. O custo de refatoração pode ficar bem alto à medida que o tempo passa e não há dimensão do escopo de refatoração. O que fazer ? Primeiramente, <strong>automatizar a verificação de atualizações.</strong> Ferramentas como NPM já fazem isso. Após ter isso mapeado, <strong>Estabeleça uma política</strong> clara para quando e como as dependências devem ser atualizadas. Isso pode incluir atualizações semestrais ou trimestrais para aquelas cuja atualização necessita de ajuste de código. <strong>Remova dependências não utilizadas,</strong> muitos projetos carregam esses pesos mortos até o fim por descuido.</p>\n<p><strong>Use ferramentas de auditoria</strong>. <strong>Quando</strong> e <strong>o que</strong> atualizar? Use <a href=\"https://legacy.reactjs.org/docs/faq-versioning.html\">versionamento semântico</a> (Semantic Versioning) para entender o impacto das atualizações (MAJOR.MINOR.PATCH).</p>\n<h4><strong>Testes</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*PJY8KEDjlmnIQR2qw9UrZg.png\"><figcaption><a href=\"https://www.netguru.com/blog/front-end-testing\">https://www.netguru.com/blog/front-end-testing</a></figcaption></figure><p>Não há um ROI explicito em escrever testes no desenvolvimento de software do ponto de vista do negócio, é algo extremamente técnico, entretanto os usuários sofrem com péssimas experiências em aplicações sem fluxo de testes porque isso aumenta a incidência de bugs.</p>\n<p>Se não considerarmos TDD ou outras práticas que priorizam testes e pensarmos em uma base de código já evoluída, <strong>o que testar</strong> é uma boa questão. Assim como qual percentual de coverage considerar.</p>\n<p><em>Importante priorizar cobertura nas áreas que mais impactam a experiência do usuário e a estabilidade da aplicação, como componentes principais da UI, lógica de gerenciamento de estado e integração com APIs.</em></p>\n<p><strong>O que ?</strong></p>\n<ol><li><strong>Camada de Apresentação (UI/UX)</strong></li></ol>\n<p><strong>Componentes de Interface</strong>:</p>\n<ul><li>\n<strong>Testes Unitários</strong>: Verificar a renderização correta de componentes individuais, props, estados e eventos.</li></ul>\n<p><strong>Fluxos de Usuário</strong>:</p>\n<ul>\n<li>\n<strong>Testes de Integração</strong>: Garantir que os componentes funcionem corretamente em conjunto e que a navegação entre as telas esteja conforme o esperado.</li>\n<li>\n<strong>Testes End-to-End (E2E)</strong>: Simular a interação do usuário com a aplicação, desde o início até o fim de um fluxo importante.</li>\n</ul>\n<p><strong>2. Camada de Lógica de Aplicação</strong></p>\n<p><strong>Gerenciamento de Estado</strong>:</p>\n<ul>\n<li>\n<strong>Testes Unitários</strong>: Verificar a lógica de atualização do estado.</li>\n<li>\n<strong>Testes de Integração</strong>: Assegurar que o estado global da aplicação seja atualizado corretamente e que os componentes reagem de maneira esperada às mudanças de estado.</li>\n</ul>\n<p><strong>3. Camada de Comunicação com Servidores (API)</strong></p>\n<p><strong>Chamadas de API</strong>:</p>\n<ul>\n<li>\n<strong>Testes Unitários</strong>: Mockar chamadas de API para verificar que as funções fazem requests corretos e lidam adequadamente com as respostas.</li>\n<li>\n<strong>Testes de Integração</strong>: Assegurar que a aplicação interaja corretamente com as APIs, lidando bem com diferentes tipos de respostas (sucesso, erro, etc).</li>\n</ul>\n<p><strong>4. Camada de Segurança</strong></p>\n<p><strong>Autenticação e Autorização</strong>:</p>\n<ul>\n<li>\n<strong>Testes Unitários</strong>: Verificar que os componentes e funções responsáveis pela autenticação e autorização se comportem conforme esperado.</li>\n<li>\n<strong>Testes de Integração</strong>: Assegurar que apenas usuários autenticados possam acessar certas partes da aplicação e que as permissões sejam corretamente aplicadas.</li>\n</ul>\n<p><strong>Cobertura de Testes (Coverage)</strong></p>\n<p><strong>Percentual de Coverage</strong>:</p>\n<ul><li>\n<strong>Meta Realista</strong>: Um percentual de cobertura entre 60% e 90% é geralmente considerado saudável. Cobertura de 100% não é necessária e pode ser impraticável, mas é crucial garantir que as partes críticas da aplicação sejam bem cobertas.</li></ul>\n<h3>Reach out to me</h3>\n<p>Espero ter esboçado meu interesse no tema de forma que contribua no seu processo. Esse não é um fim, esse tema é grande e complexo. Muitos artigos e estudo ainda estão surgindo nessa área. Com a evolução da tecnologia e a necessidade de mensurar pontas que eram meramente empíricas estão se tornando indispensáveis.</p>\n<p>Até o próximo :)</p>\n<p>Meu LinkedIn: <a href=\"https://www.linkedin.com/in/leticiamirelly/\">https://www.linkedin.com/in/leticiamirelly/</a></p>\n<h4>Referências:</h4>\n<p><em>Ruby Midwest 2011 — Keynote: Architecture the Lost Years by Robert Martin — </em><a href=\"https://www.youtube.com/watch?v=WpkDN78P884\"><em>https://www.youtube.com/watch?v=WpkDN78P884</em></a></p>\n<p><em>The cost of JavaScript in 2019 — Addy Osmani </em><a href=\"https://v8.dev/blog/cost-of-javascript-2019\"><em>https://v8.dev/blog/cost-of-javascript-2019</em></a></p>\n<p><em>Code Red: The Business Impact of Code Quality — A Quantitative Study of 39 Proprietary Production Codebases — </em><a href=\"https://arxiv.org/pdf/2203.04374\"><em>https://arxiv.org/pdf/2203.04374</em></a></p>\n<p><em>Increasing, not Diminishing: Investigating the Returns of Highly Maintainable Code — </em><a href=\"https://arxiv.org/html/2401.13407v1\">https://arxiv.org/html/2401.13407v1</a></p>\n<p><em>Principles of Developer Experience </em><a href=\"https://cpojer.net/posts/principles-of-devx#5-maximize-option-value\"><em>https://cpojer.net/posts/principles-of-devx#5-maximize-option-value</em></a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1c9d63242d21\" width=\"1\" height=\"1\" alt=\"\">\n",
			"content": "\n<h3>Construa uma vez, escale por anos — Aplicações front-end que nascem para durar.</h3>\n<a href=\"https://medium.com/media/e6590a4ef3722310fdbf785bde4228c5/href\">https://medium.com/media/e6590a4ef3722310fdbf785bde4228c5/href</a><p>Muitas decisões de negócios ainda priorizam a velocidade de entrega em detrimento da qualidade do desenvolvimento de software, resultando em consequências desastrosas. Dentre os exemplos mais recentes, em 2022, <a href=\"https://www.nytimes.com/2022/12/31/opinion/southwest-airlines-computers.html\">o sistema de agendamento de tripulações da Southwest Airlines</a> não conseguiu lidar com interrupções inesperadas no clima de inverno, levando a muitos cancelamentos de voos e perdas financeiras de aproximadamente 410 milhões de dólares. Outro exemplo é o dos voos Lion Air 610 e Ethiopian Airlines 302, ambos envolvendo aeronaves <a href=\"https://www.rollingstone.com/culture/culture-features/boeing-737-max-disasters-timeline-1235007089/\">Boeing 737 Max</a>, que tiveram parte do problema atribuída a falhas no software do sistema de controle de voo (MCAS) e na documentação.</p>\n<h4>As perguntas que tentarei responder são: Como evidenciar o impacto comercial e financeiro na performance evolutiva de uma aplicação a medida que ela cresce e quais as pontas gerir para não cair no dilema das “<a href=\"https://pt.wikipedia.org/wiki/Teoria_das_janelas_quebradas\">janelas quebradas</a>”.</h4>\n<p>Esse é um tema pretensioso, eu sei. Como desenvolvedora já trabalhei em alguns projetos legados, projetos com ciclos de vida enormes e fui “mãe” de outros, sempre questionei a fundo sobre o que aquela aplicação viria a se tornar a nível de escopo, entretanto essa é sempre uma grande variável que custa a ser mensurada. Acredito fazer sentido responder algo pretensioso assim com um punhado de referências externas e pessoais a fim de documentar estudos e experiências.</p>\n<p><em>Algumas palavras preferi manter em Inglês ao invés de traduzi-las, acredito ser mais proveitoso e eficaz manter como são comumente conhecidas.</em></p>\n<p>Com base no estudo <a href=\"https://arxiv.org/abs/2203.04374\">Code Red: The Business Impact of Code Quality</a>, 39 bases de códigos de produção foram analisados com 30.737 arquivos se baseando na métrica de Code Health da CodeScene como um proxy para qualidade de código considerando a análise de código-fonte, mineração de controle de versão e informações de emissão do Jira foi percebido que código de baixa qualidade contém 15 vezes mais defeitos do que o código de alta qualidade e códigos de baixa qualidade leva em média 124% mais tempo de desenvolvimento. O estudo evidencia ainda que até 42% do tempo dos desenvolvedores é desperdiçado lidando com dívidas técnicas, custando uma média de US$ 85 bilhões por ano. Há uma ponte a ser construída entre o time que realiza a entrega e o time comercial, com 15x menos defeitos e com mais previsibilidade do tempo de desenvolvimento e entrega, a vantagem competitiva de produzir código de qualidade de forma sustentável a longo prazo e com curto time-to-market torna-se clara.</p>\n<p>Infelizmente essa ainda não é uma visão amplamente abraçada pela área de negócio porque muitas vezes não há clareza de benefícios quantificáveis em pagar por refatorações por isso os gestores não concedem o orçamento e prioridade necessárias e acabam negociando as entregas levando em conta o curto prazo muitas vezes chegando no viés da tomada de decisão <em>desconto hiperbólico</em>, onde seus eus futuros lidam com as consequências de escolhas que prefeririam não te-las feito.</p>\n<h3><strong>KPIs da qualidade de software: idiotas da objetividade?</strong></h3>\n<p>Embora existam muitas pesquisas concentradas em nortear a qualidade de software não se pode declarar a mesma solução para todas as aplicações, entretanto podemos usar ferramentas e métodos tangíveis. Essas ferramentas são o começo, e não o fim, de como tangibilizar e negociar débitos técnicos com os gestores.</p>\n<h4>Gerenciar a Dívida técnica</h4>\n<a href=\"https://medium.com/media/523d0736ba1ed8bea0818da53353b981/href\">https://medium.com/media/523d0736ba1ed8bea0818da53353b981/href</a><p>A teoria teoria das janelas quebradas, emprestada da criminologia e aplicada no contexto do desenvolvimento de software (William Levén, <a href=\"https://arxiv.org/pdf/2209.01549\">2023</a> ), trata da relação causal entre a quantidade de débitos técnicos de uma aplicação e a propensão dos desenvolvedores inserirem novos débitos técnicos à medida que a aplicação cresce. Avaliando fatores psicológicos, o comportamento é moldado por uma norma descritiva, onde o comportamento torna-se ser aceitável. Dentre alguns insights alarmantes está a ligação entre DT e a propensão à vulnerabilidade da aplicação incluindo riscos de segurança.</p>\n<p><strong>Tipos de dívida técnica:</strong></p>\n<ul>\n<li>\n<strong>Qualidade do código: </strong>Baixa manutenibilidade, padrões de código inexistentes, mal projetado e muito complexo.</li>\n<li><strong>Baixa cobertura de código e de teste automatizado.</strong></li>\n<li><strong>Bibliotecas e/ou ferramentas desatualizadas/legadas.</strong></li>\n<li><strong>Arquitetura errada ou inexistente.</strong></li>\n<li><strong>Falta de documentação.</strong></li>\n<li><strong>Defeitos/Bugs.</strong></li>\n<li><strong>Entre outros como por exemplo processo manual de CI/CD.</strong></li>\n</ul>\n<p>Para gerenciar eficazmente há algumas etapas como: 1) <strong>identificar as dívidas,</strong> 2) <strong>Torna-las visíveis,</strong> 3) <strong>Implementar mudanças e mitigar os efeitos da dívida.</strong></p>\n<h4><strong>Dando nome às dívidas técnicas</strong></h4>\n<p>De forma prática, há algumas ferramentas de analise automática parcial do código como SonarQube que identifica violações de práticas de codificação e calcula o custo de refatoração de cada dívida. Há ainda dívidas que não são encontradas por ferramentas de analise automatizada mas são conhecidas pelo time de desenvolvimento, é aconselhável mante-las juntamente com dívidas fornecidas por uma ferramenta em um backlog técnico com a descrição do que deverá ser feito e estimativa para resolver.</p>\n<h4><strong>Mapa de débitos técnicos</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*QLDIMgUxwMsz6545GWF4Qg.jpeg\"></figure><p>Esse mapa foi tirado do <a href=\"https://blog.thepete.net/blog/2020/12/01/tech-debt-walls/\">artigo publicado por Pete Hogson </a>, onde as dívidas são colocadas em duas dimensões de <strong>custo</strong> e <strong>valor</strong>. Em suas palavras, Os problemas na área inferior esquerda do muro são “vitórias rápidas” — o tipo de cortesia que você pode receber se quiser limpar um pouco o acampamento em uma tarde tranquila de sexta-feira. Problemas na área superior esquerda do muro são “fáceis de resolver” — trabalho de baixo custo e alto valor que deve ser resolvido em breve. Por outro lado, problemas na área inferior direita do quadro são os itens “não”. O investimento simplesmente não vale a pena quando se trata desses problemas. O restante do muro contém “investimentos valiosos” — itens de dívida que provavelmente fornecerão um bom retorno sobre o investimento, mas também são substanciais o suficiente para exigir negociação com outras partes interessadas para serem priorizados.</p>\n<h4><strong>O que fazer com essas informações?</strong></h4>\n<p><a href=\"https://www.computer.org/\">Frank Buscgmann cita 3 estratégias:</a></p>\n<ul>\n<li>\n<strong>Pague a dívida: </strong>Refatorar ou substituir o código.</li>\n<li>\n<strong>Conversão de dívida: </strong>Substitua a solução atual por uma solução “boa, mas não perfeita”.</li>\n<li>\n<strong>Pague apenas os juros: </strong>Viva com o código, porque a refatoração é mais cara do que trabalhar com o código não muito correto.</li>\n</ul>\n<blockquote>\n<strong><em>A refatoração substancial é sempre uma decisão de negócios(Wolff, </em></strong><a href=\"https://www.infoq.com/articles/managing-technical-debt/\"><strong><em>2013</em></strong></a><strong><em>)</em></strong>\n</blockquote>\n<h4>Modelo de criação de valor</h4>\n<p>Uma analise aprofundada sobre o retorno do investimento em esforços de refatoração é dada no modelo de criação de valor (<a href=\"https://arxiv.org/html/2401.13407v1#abstract\">2024, </a>Markus Borg) e SPACE framework que mensura a <strong>capacidade</strong> e <strong>eficiência</strong> do time de desenvolvimento. O modelo de criação de valor concentra-se em modelos de regressão para identificar a relação entre Code Health e duas variáveis que dependem entre si: 1) número médio de defeitos e 2) tempo médio de Desvio, evidenciando como retorno da analise o impacto de mudanças relativas na qualidade do código-fonte.</p>\n<p><strong>Capacidade</strong> máxima que a organização pode alcançar em condições ideais. Maior capacidade == mais tempo de codificação;</p>\n<p><strong>Eficiência</strong> é a capacidade convertida em valor real. Maior eficiência menos interrupção.</p>\n<p><strong>𝑢</strong> = <strong>fração de trabalho não planejado</strong></p>\n<p>Eficiência = (1 — <strong>𝑢</strong>)</p>\n<blockquote>v = c × ( 1 − 𝑢 )</blockquote>\n<p>Considera-se também duas proporcionalidades: A primeira é que <em>a capacidade é inversamente proporcional ao Time-in-Dev.</em></p>\n<blockquote>Quanto mais os desenvolvedores trabalham na implementação de uma resolução, mais recursos são amarrados para lidar com ela. Esses recursos poderiam, em vez disso, ter sido alocados para o desenvolvimento de novos recursos que contribuem diretamente para a capacidade de desenvolvimento.</blockquote>\n<p>E em segundo lugar,<em> </em><strong><em>a fração de trabalho não planejado é proporcional ao número de defeitos.</em></strong></p>\n<p>Embora tenha se verificado uma não linearidade total entre Code Health e criação de valor os resultados da pesquisa sugerem que:</p>\n<ul>\n<li>As funções técnicas devem comunicar melhor os benefícios aos níveis executivos para informar as decisões estratégicas de refatoração.</li>\n<li>Evitar diligentemente cheiros de código em arquivos onde a taxa de juros sobre a dívida técnica é alta, ou seja, arquivos com rotatividade substancial.</li>\n<li>Os desenvolvedores resolvem problemas rapidamente — e possivelmente de forma imprudente — se a qualidade do código já for péssima.</li>\n</ul>\n<h3>Mais afundo — Amarrando as pontas</h3>\n<p><em>Não pretendo aprofundar na escolha da stack, poderia escrever um artigo somente sobre isso se for desejável, me deixe saber nos comentários.</em></p>\n<blockquote>if you’re afraid to change something it is clearly poorly designed.<br> — Martin Fowler</blockquote>\n<h4>High-level architecture</h4>\n<p>Arquitetura é a forma como as unidades da aplicação interagem entre si, aqui a preocupação é mais a nível estrutural do que a detalhes de implementação e/ou tecnologias de suporte. A arquitetura é guiada pelo domínio e casos de uso.</p>\n<p>Resolver questões complexas na construção de aplicações front-end tem se tornado mais simples mas não mais fácil, isso porque as arquiteturas mudaram muito nos últimos 30 anos à medida que o clássico Model View Control (MVC) evoluía para dar entrada à novas estruturas mais modernas. Curioso perceber que mesmo as estruturas mais atuais foram construídas em estruturas já existentes adicionando melhorias continuas.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*tao7a30JsPeaYv01ijFhTg.png\"><figcaption>Imagem do livro front-end reactive architectures</figcaption></figure><p><em>De antemão, não há razões determinísticas que orientem a arquitetura por um viés padrão à todas, nenhuma arquitetura é boa em si mesmo, o mesmo serve para a escolha da stack, a mais “hypada” não deveria ser escolhida por este motivo também, a escolha se baseia na necessidade do produto e do negócio.</em></p>\n<p>Na prática, representar os requisitos do software são de maior peso na balança, eles podem mudar todo o cenário, um exemplo clássico é a <a href=\"https://gustafnk.github.io/microservice-websites/\">IKEA</a> que devido ao contexto do produto decidiram implementar 2 técnicas: 1) Fragmentos autocontidos (SCS) em uma arquitetura micro front-end que atende a demandas de equipes diferentes com funcionalidades compartilhadas levando a um maior reaproveitamento do esforço de desenvolvimento e entregando somente o que cada fragmento precisa como CSS e JS, e 2) Edge Side Includes (ESI) que entrega dinamicamente para cada fragmento o que é necessário quando solicitado.</p>\n<p>É comum a separação de responsabilidade por camadas no front-end e, também, no backend, isso porque os atores da aplicação possuem objetivos diferentes, ( Não confunda isso com estrutura de pastas ) as camadas nesse nível representam as partes independentes da aplicação como por exemplo a camada de entrada e infraestrutura cada uma com seu objetivo.</p>\n<p><strong>Padrões arquiteturais amplos</strong></p>\n<p><em>First thing: Design Pattern ≠ Arquitetura</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/981/1*vfxVbZCaVvIhp8H333TEJQ.png\"><figcaption><a href=\"https://leanylabs.com/blog/micro-frontends-overview/\">https://leanylabs.com/blog/micro-frontends-overview/</a></figcaption></figure><p><strong>Arquitetura Monolítica</strong></p>\n<p>Abordagem mais tradicional onde todos os componentes são integrados em uma única base de código. Este modelo simplifica o desenvolvimento inicial e o deployment, mas pode levar a problemas de escalabilidade e manutenção à medida que a aplicação cresce. Modificações em uma pequena parte do sistema podem exigir a recompilação e redeployment de toda a aplicação.</p>\n<p><strong>Arquitetura Micro front-end</strong></p>\n<p>Aplica os princípios de microserviços ao front-end, onde a interface do usuário é dividida em componentes menores e independentes. Cada componente é responsável por uma parte específica da interface e pode ser desenvolvido, implantado e atualizado de forma independente. Esta abordagem permite uma maior flexibilidade e escalabilidade no desenvolvimento de interfaces complexas.</p>\n<p>Há algumas escolhas estratégicas de <strong><em>como</em></strong> todas as partes da aplicação irá conversar, além disso, <strong><em>onde</em></strong> será renderizada (cliente/servidor/isomórfico — Podem incluir hidratação parcial e progressiva dando mais poderes a aplicação e não sobrecarregando o cliente), <strong><em>quando</em></strong> será integrada (estático/dinâmico) e <strong><em>o que</em></strong> será integrado.</p>\n<h4><strong>State management</strong></h4>\n<p>Manter uma única fonte de verdade é uma das estratégias da <strong>camada de estado da aplicação</strong>, não há alterações diretas na camada <strong>view</strong> e sim dispatchs para um estado central que modifica a fonte, isso assegura que todos os observadores estejam alinhados. Essa camada não esta diretamente conectada ao uso de bibliotecas como Redux, Vuex ou NgRx store e sim a uma estratégia de envio de eventos a um armazenador de estado.</p>\n<h4><strong>Gerenciamento de versão de dependências</strong></h4>\n<p>Talvez essa seja a ponta mais subestimada. No planejamento dos ciclos de entrega quantas vezes se fala em separar tempo + esforço para atualizar o framework/biblioteca usada na construção da aplicação? Ou de bibliotecas de suporte? Considere que anualmente novas majors release são lançadas e a versão que seu software usa muitas vezes sequer recebe suporte pela equipe dona da ferramenta. O custo de refatoração pode ficar bem alto à medida que o tempo passa e não há dimensão do escopo de refatoração. O que fazer ? Primeiramente, <strong>automatizar a verificação de atualizações.</strong> Ferramentas como NPM já fazem isso. Após ter isso mapeado, <strong>Estabeleça uma política</strong> clara para quando e como as dependências devem ser atualizadas. Isso pode incluir atualizações semestrais ou trimestrais para aquelas cuja atualização necessita de ajuste de código. <strong>Remova dependências não utilizadas,</strong> muitos projetos carregam esses pesos mortos até o fim por descuido.</p>\n<p><strong>Use ferramentas de auditoria</strong>. <strong>Quando</strong> e <strong>o que</strong> atualizar? Use <a href=\"https://legacy.reactjs.org/docs/faq-versioning.html\">versionamento semântico</a> (Semantic Versioning) para entender o impacto das atualizações (MAJOR.MINOR.PATCH).</p>\n<h4><strong>Testes</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*PJY8KEDjlmnIQR2qw9UrZg.png\"><figcaption><a href=\"https://www.netguru.com/blog/front-end-testing\">https://www.netguru.com/blog/front-end-testing</a></figcaption></figure><p>Não há um ROI explicito em escrever testes no desenvolvimento de software do ponto de vista do negócio, é algo extremamente técnico, entretanto os usuários sofrem com péssimas experiências em aplicações sem fluxo de testes porque isso aumenta a incidência de bugs.</p>\n<p>Se não considerarmos TDD ou outras práticas que priorizam testes e pensarmos em uma base de código já evoluída, <strong>o que testar</strong> é uma boa questão. Assim como qual percentual de coverage considerar.</p>\n<p><em>Importante priorizar cobertura nas áreas que mais impactam a experiência do usuário e a estabilidade da aplicação, como componentes principais da UI, lógica de gerenciamento de estado e integração com APIs.</em></p>\n<p><strong>O que ?</strong></p>\n<ol><li><strong>Camada de Apresentação (UI/UX)</strong></li></ol>\n<p><strong>Componentes de Interface</strong>:</p>\n<ul><li>\n<strong>Testes Unitários</strong>: Verificar a renderização correta de componentes individuais, props, estados e eventos.</li></ul>\n<p><strong>Fluxos de Usuário</strong>:</p>\n<ul>\n<li>\n<strong>Testes de Integração</strong>: Garantir que os componentes funcionem corretamente em conjunto e que a navegação entre as telas esteja conforme o esperado.</li>\n<li>\n<strong>Testes End-to-End (E2E)</strong>: Simular a interação do usuário com a aplicação, desde o início até o fim de um fluxo importante.</li>\n</ul>\n<p><strong>2. Camada de Lógica de Aplicação</strong></p>\n<p><strong>Gerenciamento de Estado</strong>:</p>\n<ul>\n<li>\n<strong>Testes Unitários</strong>: Verificar a lógica de atualização do estado.</li>\n<li>\n<strong>Testes de Integração</strong>: Assegurar que o estado global da aplicação seja atualizado corretamente e que os componentes reagem de maneira esperada às mudanças de estado.</li>\n</ul>\n<p><strong>3. Camada de Comunicação com Servidores (API)</strong></p>\n<p><strong>Chamadas de API</strong>:</p>\n<ul>\n<li>\n<strong>Testes Unitários</strong>: Mockar chamadas de API para verificar que as funções fazem requests corretos e lidam adequadamente com as respostas.</li>\n<li>\n<strong>Testes de Integração</strong>: Assegurar que a aplicação interaja corretamente com as APIs, lidando bem com diferentes tipos de respostas (sucesso, erro, etc).</li>\n</ul>\n<p><strong>4. Camada de Segurança</strong></p>\n<p><strong>Autenticação e Autorização</strong>:</p>\n<ul>\n<li>\n<strong>Testes Unitários</strong>: Verificar que os componentes e funções responsáveis pela autenticação e autorização se comportem conforme esperado.</li>\n<li>\n<strong>Testes de Integração</strong>: Assegurar que apenas usuários autenticados possam acessar certas partes da aplicação e que as permissões sejam corretamente aplicadas.</li>\n</ul>\n<p><strong>Cobertura de Testes (Coverage)</strong></p>\n<p><strong>Percentual de Coverage</strong>:</p>\n<ul><li>\n<strong>Meta Realista</strong>: Um percentual de cobertura entre 60% e 90% é geralmente considerado saudável. Cobertura de 100% não é necessária e pode ser impraticável, mas é crucial garantir que as partes críticas da aplicação sejam bem cobertas.</li></ul>\n<h3>Reach out to me</h3>\n<p>Espero ter esboçado meu interesse no tema de forma que contribua no seu processo. Esse não é um fim, esse tema é grande e complexo. Muitos artigos e estudo ainda estão surgindo nessa área. Com a evolução da tecnologia e a necessidade de mensurar pontas que eram meramente empíricas estão se tornando indispensáveis.</p>\n<p>Até o próximo :)</p>\n<p>Meu LinkedIn: <a href=\"https://www.linkedin.com/in/leticiamirelly/\">https://www.linkedin.com/in/leticiamirelly/</a></p>\n<h4>Referências:</h4>\n<p><em>Ruby Midwest 2011 — Keynote: Architecture the Lost Years by Robert Martin — </em><a href=\"https://www.youtube.com/watch?v=WpkDN78P884\"><em>https://www.youtube.com/watch?v=WpkDN78P884</em></a></p>\n<p><em>The cost of JavaScript in 2019 — Addy Osmani </em><a href=\"https://v8.dev/blog/cost-of-javascript-2019\"><em>https://v8.dev/blog/cost-of-javascript-2019</em></a></p>\n<p><em>Code Red: The Business Impact of Code Quality — A Quantitative Study of 39 Proprietary Production Codebases — </em><a href=\"https://arxiv.org/pdf/2203.04374\"><em>https://arxiv.org/pdf/2203.04374</em></a></p>\n<p><em>Increasing, not Diminishing: Investigating the Returns of Highly Maintainable Code — </em><a href=\"https://arxiv.org/html/2401.13407v1\">https://arxiv.org/html/2401.13407v1</a></p>\n<p><em>Principles of Developer Experience </em><a href=\"https://cpojer.net/posts/principles-of-devx#5-maximize-option-value\"><em>https://cpojer.net/posts/principles-of-devx#5-maximize-option-value</em></a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1c9d63242d21\" width=\"1\" height=\"1\" alt=\"\">\n",
			"enclosure": {},
			"categories": [
				"arquitetura",
				"desenvolvimento",
				"front-end-development"
			]
		},
		{
			"title": "Enhancing Front-End Decision-Making: Navigating the Choice Between Nuxt.js and Vue.js",
			"pubDate": "2024-01-12 04:06:01",
			"link": "https://leticia-mirelly.medium.com/enhancing-front-end-decision-making-navigating-the-choice-between-nuxt-js-and-vue-js-26ff459f0f74?source=rss-7deace8b3a8e------2",
			"guid": "https://medium.com/p/26ff459f0f74",
			"author": "Leticia Mirelly ϟ",
			"thumbnail": "",
			"description": "\n<a href=\"https://medium.com/media/7b629623f8be94d54e2cc499aff3ed44/href\">https://medium.com/media/7b629623f8be94d54e2cc499aff3ed44/href</a><blockquote>Let me give you a small introduction before I begin</blockquote>\n<h3><strong>Brief Introduction to Vue.js</strong></h3>\n<p>Vue.js was originally created by Evan You in 2014 and has since garnered significant contributions from the community. It emerged in the market as a lightweight and intuitive alternative to the dominant frontend frameworks such as Angular and React. Its value proposition lies in combining an easy learning curve with powerful reactivity and flexibility. The Vue.js 3 team includes seasoned engineers, many of whom have contributed to other popular frameworks and libraries, bringing a diversity of experiences to the project. The source code and repository of Vue.js 2 are maintained in a central repository. While the Vue.js 2 source code is well-structured, the monolithic nature of the repository can pose challenges in managing new features and experiments. On the other hand, Vue.js 3 adopted a modular approach and used a monorepo for code management, which has facilitated maintenance, testing, and the addition of new features.</p>\n<h4>Component-Oriented Architecture</h4>\n<p>Component-Oriented Architecture Vue.js extends HTML with a template syntax that allows for the declarative expression of DOM rendering based on the state of the application’s data. To render the user interface, Vue.js uses a Virtual DOM — a lightweight representation of the real DOM. This enables Vue.js to calculate the minimal changes needed to update the UI without re-rendering the entire DOM tree. Vue.js implements a highly optimized “diff” algorithm that compares the Virtual DOM with a previous version to detect the exact differences. This results in a minimum number of DOM manipulations. The declarative templates are compiled into JavaScript rendering functions. These functions return Virtual DOM trees whenever the component data changes, which is excellent for performance.</p>\n<h4>Reactivity</h4>\n<p>There are two ways to intercept property access in JavaScript: getters/setters and Proxies. Vue 2 exclusively used getters/setters due to browser support limitations. In Vue 3, Proxies are used for reactive objects, and getters/setters are used for refs.Reactivity based on Proxies reduces the initialization overhead of components. In Vue.js 2, the need to recursively convert all properties of an object into getters/setters increased the startup time, particularly for large datasets.Projects in Vue.js 2 typically rely on tools like Webpack and Vue Loader to process .vue files and generate bundles. This approach can depend on specific configurations and plugins to work correctly. Vue.js 3 is developed and maintained as a monorepo, which includes sub-packages like @vue/runtime-dom and @vue/reactivity. This allows projects to import only the parts of Vue they need, reducing the size of the final bundle. With Vue.js 3, there is a growing movement towards the use of more modern and efficient build tools like Vite, which leverages ES modules for faster development.</p>\n<h4>Some comparisons with other frameworks</h4>\n<p>Vue.js offers a declarative approach to building UIs that is more straightforward and less verbose than Angular. Compared to React’s JSX, Vue’s templates are closer to HTML, making them more accessible to beginners and developers with strong HTML/CSS experience.</p>\n<p>Vue.js introduced the concept of Single-File Components (SFCs), which encapsulate a component’s template, logic, and styles in a single file. This approach simplifies code organization and enhances clarity compared to the separate methods of managing template and logic in frameworks like Angular. The Vue ecosystem includes official solutions for routing (Vue Router) and state management (Vuex) that are designed to work seamlessly with Vue core. React and Angular also have strong ecosystems, but Vue benefits from tighter integration and a less complex state management model compared to Redux in React.</p>\n<h4>\n<em>For new projects, it’s highly recommended to use the latest version of Vue.js, which, at the moment, is </em><a href=\"https://blog.vuejs.org/posts/vue-3-one-piece\"><em>Vue.js 3</em></a><em>. This version brings significant improvements in terms of performance, enhanced reactivity through the Proxy-based system, the Composition API for better code organization, along with other advanced features.</em>\n</h4>\n<h4><em>If migrating to Vue.js 3 is not feasible at the moment, maintaining the latest minor or patch version of Vue.js 2 is advisable, especially to ensure security and compatibility with current libraries.</em></h4>\n<p><em>If you missed it, Vue.js 2 became obsolete along with the packages on npm since December 31, 2023:</em></p>\n<ul>\n<li><em>All major and minor versions of Vue 2 core</em></li>\n<li><em>Versions of vue-router with exclusive support for Vue 2 (3.x and below)</em></li>\n<li><em>Vuex versions with exclusive support for Vue 2 (3.x and below)</em></li>\n</ul>\n<p><em>More details can be found at: </em><a href=\"https://blog.vuejs.org/posts/vue-2-eol\"><em>https://blog.vuejs.org/posts/vue-2-eol</em></a></p>\n<h4>Boilerplates for Creating Vue.js Projects</h4>\n<p><strong><em>Vite</em></strong> is a next-generation build tool that significantly improves the development experience. It uses Rollup for production builds and features an extremely fast development server based on native ES modules. It is ideal for projects seeking speed in the development and build process. Its rapid hot-module reloading (HMR) and simplified configuration make it suitable for modern SPAs and Vue.js projects that demand high-performance.</p>\n<p><strong><em>Vue CLI</em></strong> is the standard tool for creating Vue.js projects. It offers a rich set of configuration options, plugins, and a GUI for project management. It is well-suited for developers who prefer a more traditional and comprehensive setup for their Vue.js applications.</p>\n<p><strong><em>Quasar</em></strong> is a Vue.js framework that enables developers to build SPA, SSR, PWA, Mobile (using Cordova or Capacitor), and Electron applications with a single codebase. It is best for projects that require multiple platform/rendering solutions with a unified codebase, providing versatility and efficiency in development.</p>\n<p>In addition to these, there are other notable templates and frameworks in the Vue.js ecosystem, each offering unique features and benefits to cater to different needs and preferences in web and application development.</p>\n<h3><strong>Brief Introduction to Nuxt.js</strong></h3>\n<p>Nuxt.js was created by French brothers Sébastien and Alexandre Chopin, with its first version released in 2016. The goal was to create a framework that simplified the development process with Vue.js, focusing particularly on server-side rendering (SSR) and automatic configuration.</p>\n<p>Nuxt.js is particularly valued for its ability to improve SEO (Search Engine Optimization) and the initial page loading performance, which are common challenges in Single Page Applications (SPAs). It simplifies the implementation of SSR by automating much of the process. This includes setting up the server, rendering Vue.js components, and managing synchronization between server and client. It also offers the capability to generate a static site. This means that all application pages are pre-rendered during the build process, generating static HTML files.</p>\n<p>From the outset, Nuxt.js was developed to complement and enhance Vue.js’s capabilities. For example, automatic routing is one of Nuxt.js’s most attractive features, eliminating the need to manually define application routes using Vue Router. During the build process, Nuxt.js automatically generates the Vue Router configuration based on the structure of the ‘pages’ directory.</p>\n<p>Nuxt.js utilizes a specific directory structure that includes pages, components, layouts, plugins, middleware, assets, and static. This structure is an integral part of Nuxt.js’s convention-over-configuration approach. Plugins are frequently used to add global libraries (like Axios for HTTP requests or Vuetify as a UI library) or to inject global functions and constants.</p>\n<h4>Applications with Strong SEO Needs</h4>\n<p>For applications that rely on good visibility in search engines, like blogs and e-commerce sites, server-side rendering (SSR) is essential. SSR ensures that the content is fully rendered on the server side, making it more easily indexable by search engines, which is crucial for SEO.</p>\n<h4>High-Performance Websites</h4>\n<p>For websites where loading performance is crucial, such as portfolios or corporate pages, static site generation offers the best solution. Static sites are faster to load and more efficient in terms of server resource usage because the HTML is pre-rendered and ready to be served instantly.</p>\n<p>Nuxt.js uses Webpack as its module bundler. During the build process, Webpack processes and packages resources such as JavaScript, Vue components, CSS, and images. This bundling is vital for optimizing application performance, as it reduces the number of requests needed to load a webpage and can include optimizations like minification and tree shaking.</p>\n<h4>Dependency Management and Versioning</h4>\n<p>Nuxt.js also adopts SemVer, and each version of Nuxt is typically built to work with a specific version of Vue.js. For instance, Nuxt.js v2 is compatible with Vue.js v2.x, while Nuxt.js v3 is designed to work with Vue.js v3. This ensures that when a developer chooses a specific version of Nuxt.js, they can be confident about which version of Vue.js it is compatible with, which is crucial for maintaining consistency and stability in application development.</p>\n<h4>Evolution of Nuxt.js: From Early to Current Versions</h4>\n<p><a href=\"https://medium.com/@nuxt_js/nuxt-js-1-0-is-out-bab1af459972\"><strong><em>Nuxt.js 1.x</em></strong></a><strong> </strong>The early versions of Nuxt.js focused on providing a framework for Vue.js applications with server-side rendering (SSR) out-of-the-box. This approach simplified the development of SSR and SPA (Single Page Application) applications, making it easier for developers to create complex, SEO-friendly web applications without dealing with the intricacies of server-side rendering configurations.</p>\n<p><a href=\"https://medium.com/@nuxt_js/nuxt-js-2-0-webpack-4-esm-modules-create-nuxt-app-and-more-6936ce80d94c\"><strong><em>Nuxt.js 2.x</em></strong></a><strong><em> </em></strong>Updates in this series brought significant improvements, such as Static Site Generation (SSG) and automatic optimization for performance. There were also advances in modularity and extensibility, with the introduction of Nuxt.js modules that could add functionality to the framework without the need for extensive manual configuration. This version made Nuxt.js more flexible and powerful, catering to a wider range of web development needs.</p>\n<p><a href=\"https://nuxt.com/docs/getting-started/installation\"><strong><em>Transition to Vue.js 3</em></strong></a> The introduction of Vue.js 3, with features like the Composition API, Proxy-based reactivity, and enhanced TypeScript support, necessitated corresponding adaptations in Nuxt.js. This led to the development and eventual release of Nuxt.js 3, which was a significant step in keeping the framework aligned with the latest Vue.js features and improvements.</p>\n<p><strong><em>Nuxt.js 3 and Beyond</em></strong><em> </em>Nuxt.js 3 was designed to leverage all the new functionalities of Vue.js 3. It offers a rewrite of the core to use the Composition API, improves support for TypeScript, and incorporates performance enhancements from the new version of Vue.js. This version represents a major leap forward in terms of developer experience, performance, and capabilities, making it a robust choice for modern web development.</p>\n<h3>Detailed Comparison</h3>\n<p>When comparing Vue.js and Nuxt.js, it’s crucial to understand that they are not direct competitors but complementary to each other. Vue.js is a progressive framework for building user interfaces, while Nuxt.js is a framework based on Vue.js, designed to simplify the development of universal (SSR) and single-page applications (SPAs).</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/631/1*rKtYy2yw9tjc6IgWLGyAmA.png\"></figure><h4>Main Use</h4>\n<ul><li>\n<strong>Vue.js</strong> is ideal for building dynamic user interfaces. <strong>Nuxt.js</strong>, being a layer on top of Vue.js, is more suitable for projects that require server-side rendering or static site generation.</li></ul>\n<h4>Routing</h4>\n<ul><li>\n<strong>Vue.js</strong> offers flexibility in routing but requires manual configuration. <strong>Nuxt.js</strong> automates this process, making routing easier based on the directory structure.</li></ul>\n<h4>SEO and Performance</h4>\n<ul><li>\n<strong>SPAs in Vue.js</strong> may face challenges with SEO due to their client-side nature. <strong>Nuxt.js</strong> addresses these issues with SSR and SSG, offering better SEO practices and faster initial loading times.</li></ul>\n<h4>Project Structure</h4>\n<ul><li>While <strong>Vue.js allows for a more flexible approach to project structuring</strong>, <strong>Nuxt.js offers a more standardized project structure</strong>, which can speed up development, especially in larger projects.</li></ul>\n<p>When evaluating Vue.js and Nuxt.js from the perspectives of <strong>scalability</strong>, <strong>maintainability</strong>, and <strong>performance</strong>, we are considering how these technologies behave as applications grow in complexity and size, and how they facilitate ongoing maintenance.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/519/1*Wa2ri_btTNzQAUmgUpiEOg.png\"></figure><h3>Nuxt.js Case Study: Large-Scale E-Commerce</h3>\n<h4>Platform Developing a robust e-commerce platform, with thousands of products, high user customization, and strict SEO and performance demands.</h4>\n<p><strong><em>Server-Side Rendering (SSR) for SEO and Performance:</em></strong> Traditional SPAs face challenges with SEO and initial load time.<strong><em> Solution:</em></strong> With native SSR, Nuxt.js significantly improves SEO and page loading speed, which is crucial for an e-commerce site.</p>\n<p><strong><em>Static Site Generation (SSG) for Product Pages:</em></strong> Maintaining performance with a large number of product pages. <strong><em>Solution:</em></strong> Using SSG, Nuxt.js can generate static pages for each product, reducing server load and improving loading speed. Project Structure and Automatic Routing.</p>\n<p><strong><em>Managing a large codebase and complex routing. Solution:</em></strong> Nuxt.js’s project structure and automatic routing simplify code organization and route management, increasing development efficiency.</p>\n<p><strong><em>Modularity and Plugins:</em> </strong>Integrating various features such as payment systems, inventory management, and user customization. <strong>Solution:</strong> The modular architecture of Nuxt.js and support for plugins allow for clean and maintainable integration of complex functionalities. Internationalization and Localization</p>\n<p><strong><em>Adapting the platform for multiple languages and regions. Solution:</em></strong> With the nuxt-i18n module, the platform can easily support multiple languages, facilitating content localization.</p>\n<h4><strong>Results and Benefits</strong></h4>\n<p><strong><em>Improved User Experience: </em></strong>The application loads quickly, even with a large amount of dynamic content, thanks to SSR and SSG.</p>\n<p><strong><em>Simplified Maintenance:</em> </strong>Maintenance is easier due to the organized structure and the ease of updates and integrations.</p>\n<p><strong><em>Assured Scalability:</em></strong> The site is able to handle an increase in traffic and product quantity without sacrificing performance.</p>\n<h3>Vue.js Case Study: Analytics Dashboard Platform</h3>\n<h4><strong>Create an interactive analytics dashboard for a medium-sized company, providing real-time insights into sales data, customer engagement, and product performance.</strong></h4>\n<p><strong><em>Rapid and Iterative Development. Solution:</em></strong> With Vue CLI, the project can be quickly bootstrapped, and Vue.js’s declarative syntax and reusable components allow for fast iterative development.</p>\n<p><strong><em>Performance and Optimization:</em></strong> Ensuring smooth performance with large volumes of data. <strong><em>Solution</em></strong>: Vue.js offers an efficient reactive system and Virtual DOM to optimize UI updates, maintaining performance even with large data volumes.</p>\n<p><strong><em>Scalability and Maintenance:</em> </strong>The application must be easy to scale and maintain.<strong><em> Solution: </em></strong>The modular and component-based architecture of Vue.js, along with an active community and excellent documentation, facilitate scalability and maintenance.</p>\n<h4>Results and Benefits</h4>\n<p><strong><em>Development Agility:</em></strong> The prototype was developed and iterated quickly, thanks to the ease of use of Vue.js.</p>\n<p><strong><em>Optimized Performance: </em></strong>The dashboard maintained high performance, even when handling and displaying data in real-time.</p>\n<h3>Guidelines for Efficient Code Architecture</h3>\n<h4>Modularity and Encapsulation</h4>\n<p><strong><em>Component-Oriented Design: </em></strong>Divide the application into smaller, independent components. This not only facilitates reuse and maintenance but also allows for more efficient testing.</p>\n<p><strong><em>Component Encapsulation:</em></strong> Use encapsulation to hide the internal complexity of components, exposing only clear and well-defined interfaces.</p>\n<h4>Clean and Separated Architecture</h4>\n<p><strong><em>Model-View-ViewModel (MVVM) Pattern: </em></strong>Separate business logic (Model), presentation layer (View), and presentation logic (ViewModel). This promotes efficient decoupling and facilitates unit testing.</p>\n<p><strong><em>Service Layer:</em></strong> Introduce a service layer to abstract business logic and interactions with external APIs or the backend.</p>\n<h4>State Management Patterns</h4>\n<p>State management patterns are crucial in frontend applications, especially as complexity and size increase. These patterns provide an organized framework for managing and maintaining application state predictably and efficiently.</p>\n<p><strong><em>Vuex </em></strong>is a state management pattern and library for Vue.js applications. It serves as a centralized store for all components in an application. Features: Deep integration with Vue’s reactivity system. Concepts of state, getters, actions, and mutations. Facilitates the maintenance and management of shared states in large Vue applications.</p>\n<p><strong><em>Pinia</em></strong> is the latest addition to the Vue.js ecosystem as an alternative to Vuex for state management. Developed with Vue 3’s Composition API in mind, Pinia offers a more intuitive and flexible state management experience. <strong><em>Stores as State Sources</em> </strong>In Pinia, each “store” is essentially a source of reactive state. Stores are lighter and more flexible compared to Vuex stores. <strong><em>Hot Module Replacement (HMR),</em></strong> meaning store state can be preserved during hot-reloading during development. Easy to Learn and Use Pinia’s framework and API are simpler and more straightforward, making it easier to learn and use, especially for new Vue developers.</p>\n<h4>Routing and Lazy Loading</h4>\n<p>Implement dynamic routing and permission-based routing to manage access to different areas of the application.</p>\n<h4>Advanced CSS Practices</h4>\n<p>Adopt methodologies like BEM, SMACSS, or OOCSS to maintain scalable and maintainable styles.</p>\n<h4>Automated Testing</h4>\n<p>Implement unit tests, integration tests, and end-to-end (E2E) tests to ensure code quality.</p>\n<h4>Linting and Code Formatting</h4>\n<p>Use tools like ESLint and Prettier to maintain code consistency and identify potential issues early on.</p>\n<blockquote>An efficient code architecture in frontend projects requires a holistic approach that encompasses everything from component structure to advanced state management practices and performance optimization. These guidelines are essential for creating scalable, efficient, and easy-to-maintain applications, suitable for the complex needs of web development.</blockquote>\n<h3>Tips for optimizing code performance and maintenance: Strategies to keep code clean and performant</h3>\n<h4>Clean Code Principles</h4>\n<p><strong><em>Readability:</em> </strong>Write code as if it were a book. This includes descriptive variable and function names, as well as a clear logical structure.</p>\n<p><strong><em>Simplicity: </em></strong>Avoid unnecessary complexity. Simpler solutions are often easier to maintain.</p>\n<p><strong><em>DRY (Don’t Repeat Yourself): </em></strong>Eliminate code repetition. Reuse code whenever possible to reduce duplication and ease future changes.</p>\n<p><strong><em>Efficient State Management (</em></strong><em>Local vs. Global State): </em>Carefully assess the need for global state. Use local state whenever possible to reduce complexity.</p>\n<p><strong><em>Caching and Memoization: </em></strong>Implement caching and memoization for heavy operations, such as API queries or complex calculations.</p>\n<h3>Conclusion</h3>\n<h4>Features and Practices</h4>\n<p><strong>Vue.js — Flexibility and Intuitiveness: </strong>Vue.js is ideal for SPAs and dynamic user interfaces, known for its smooth learning curve, componentization, and efficient reactivity.</p>\n<p><strong>Nuxt.js — Structure and Optimization: </strong>Nuxt.js extends Vue.js capabilities, offering standardized structures and additional features like SSR and SSG, ideal for projects requiring enhanced SEO and performance.</p>\n<p><strong>Design Patterns and Code Architecture: </strong>Adopting clear design patterns and efficient code architecture, such as modularity, encapsulation, and state management, is crucial for scalability and maintainability.</p>\n<h3><strong>Choosing between Vue.js and Nuxt.js for a specific project depends on various factors related to the project’s needs and objectives. Here are some final guidelines to help make this decision:</strong></h3>\n<h4>Considering the Scope and Project Requirements</h4>\n<p><strong>Vue.js: </strong>Ideal for projects that require a flexible and customizable approach, such as Single Page Applications (SPAs) or when integrating Vue into an existing project.</p>\n<p><strong>Nuxt.js:</strong> Better suited for projects that benefit from Server-Side Rendering (SSR) or Static Site Generation (SSG), such as applications that need improved SEO and better initial loading performance.</p>\n<h4>Evaluating Team Experience and Available Resources</h4>\n<p><strong>Learning Curve: </strong>Teams already familiar with Vue.js will find it easy to adopt Nuxt.js, but for those who are new to both, Vue.js can be a more accessible starting point due to its smoother learning curve.</p>\n<p><strong>Resources and Community:</strong> Both have active communities and a good number of available resources. Considering community support and resources can be crucial, especially for smaller teams or projects with limited budgets.</p>\n<h4>SEO and Performance</h4>\n<p>If SEO and initial loading performance are priorities, Nuxt.js with its integrated SSR and SSG is the most suitable choice.</p>\n<h4>Flexibility vs. Convention</h4>\n<p><strong>Vue.js: </strong>Offers greater flexibility in structuring the project. <strong>Nuxt.js:</strong> Provides directory structure conventions that can speed up development and ensure consistency, especially useful in larger teams or projects with many developers.</p>\n<p><em>The choice between Vue.js and Nuxt.js should be based on a careful assessment of the project’s specific needs, available resources, and the development team’s experience. Vue.js is better suited for projects that require a flexible and customizable approach, while Nuxt.js is ideal for projects that need advanced features like SSR and SSG for SEO and performance. Evaluating these factors will help ensure that the chosen technology aligns with the project’s goals and requirements, maximizing development efficiency and success.</em></p>\n<blockquote>Feel free to <a href=\"https://www.linkedin.com/in/leticiamirelly/\">connect with me on LinkedIn</a> for any further discussions or questions you may have. Happy coding!</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=26ff459f0f74\" width=\"1\" height=\"1\" alt=\"\">\n",
			"content": "\n<a href=\"https://medium.com/media/7b629623f8be94d54e2cc499aff3ed44/href\">https://medium.com/media/7b629623f8be94d54e2cc499aff3ed44/href</a><blockquote>Let me give you a small introduction before I begin</blockquote>\n<h3><strong>Brief Introduction to Vue.js</strong></h3>\n<p>Vue.js was originally created by Evan You in 2014 and has since garnered significant contributions from the community. It emerged in the market as a lightweight and intuitive alternative to the dominant frontend frameworks such as Angular and React. Its value proposition lies in combining an easy learning curve with powerful reactivity and flexibility. The Vue.js 3 team includes seasoned engineers, many of whom have contributed to other popular frameworks and libraries, bringing a diversity of experiences to the project. The source code and repository of Vue.js 2 are maintained in a central repository. While the Vue.js 2 source code is well-structured, the monolithic nature of the repository can pose challenges in managing new features and experiments. On the other hand, Vue.js 3 adopted a modular approach and used a monorepo for code management, which has facilitated maintenance, testing, and the addition of new features.</p>\n<h4>Component-Oriented Architecture</h4>\n<p>Component-Oriented Architecture Vue.js extends HTML with a template syntax that allows for the declarative expression of DOM rendering based on the state of the application’s data. To render the user interface, Vue.js uses a Virtual DOM — a lightweight representation of the real DOM. This enables Vue.js to calculate the minimal changes needed to update the UI without re-rendering the entire DOM tree. Vue.js implements a highly optimized “diff” algorithm that compares the Virtual DOM with a previous version to detect the exact differences. This results in a minimum number of DOM manipulations. The declarative templates are compiled into JavaScript rendering functions. These functions return Virtual DOM trees whenever the component data changes, which is excellent for performance.</p>\n<h4>Reactivity</h4>\n<p>There are two ways to intercept property access in JavaScript: getters/setters and Proxies. Vue 2 exclusively used getters/setters due to browser support limitations. In Vue 3, Proxies are used for reactive objects, and getters/setters are used for refs.Reactivity based on Proxies reduces the initialization overhead of components. In Vue.js 2, the need to recursively convert all properties of an object into getters/setters increased the startup time, particularly for large datasets.Projects in Vue.js 2 typically rely on tools like Webpack and Vue Loader to process .vue files and generate bundles. This approach can depend on specific configurations and plugins to work correctly. Vue.js 3 is developed and maintained as a monorepo, which includes sub-packages like @vue/runtime-dom and @vue/reactivity. This allows projects to import only the parts of Vue they need, reducing the size of the final bundle. With Vue.js 3, there is a growing movement towards the use of more modern and efficient build tools like Vite, which leverages ES modules for faster development.</p>\n<h4>Some comparisons with other frameworks</h4>\n<p>Vue.js offers a declarative approach to building UIs that is more straightforward and less verbose than Angular. Compared to React’s JSX, Vue’s templates are closer to HTML, making them more accessible to beginners and developers with strong HTML/CSS experience.</p>\n<p>Vue.js introduced the concept of Single-File Components (SFCs), which encapsulate a component’s template, logic, and styles in a single file. This approach simplifies code organization and enhances clarity compared to the separate methods of managing template and logic in frameworks like Angular. The Vue ecosystem includes official solutions for routing (Vue Router) and state management (Vuex) that are designed to work seamlessly with Vue core. React and Angular also have strong ecosystems, but Vue benefits from tighter integration and a less complex state management model compared to Redux in React.</p>\n<h4>\n<em>For new projects, it’s highly recommended to use the latest version of Vue.js, which, at the moment, is </em><a href=\"https://blog.vuejs.org/posts/vue-3-one-piece\"><em>Vue.js 3</em></a><em>. This version brings significant improvements in terms of performance, enhanced reactivity through the Proxy-based system, the Composition API for better code organization, along with other advanced features.</em>\n</h4>\n<h4><em>If migrating to Vue.js 3 is not feasible at the moment, maintaining the latest minor or patch version of Vue.js 2 is advisable, especially to ensure security and compatibility with current libraries.</em></h4>\n<p><em>If you missed it, Vue.js 2 became obsolete along with the packages on npm since December 31, 2023:</em></p>\n<ul>\n<li><em>All major and minor versions of Vue 2 core</em></li>\n<li><em>Versions of vue-router with exclusive support for Vue 2 (3.x and below)</em></li>\n<li><em>Vuex versions with exclusive support for Vue 2 (3.x and below)</em></li>\n</ul>\n<p><em>More details can be found at: </em><a href=\"https://blog.vuejs.org/posts/vue-2-eol\"><em>https://blog.vuejs.org/posts/vue-2-eol</em></a></p>\n<h4>Boilerplates for Creating Vue.js Projects</h4>\n<p><strong><em>Vite</em></strong> is a next-generation build tool that significantly improves the development experience. It uses Rollup for production builds and features an extremely fast development server based on native ES modules. It is ideal for projects seeking speed in the development and build process. Its rapid hot-module reloading (HMR) and simplified configuration make it suitable for modern SPAs and Vue.js projects that demand high-performance.</p>\n<p><strong><em>Vue CLI</em></strong> is the standard tool for creating Vue.js projects. It offers a rich set of configuration options, plugins, and a GUI for project management. It is well-suited for developers who prefer a more traditional and comprehensive setup for their Vue.js applications.</p>\n<p><strong><em>Quasar</em></strong> is a Vue.js framework that enables developers to build SPA, SSR, PWA, Mobile (using Cordova or Capacitor), and Electron applications with a single codebase. It is best for projects that require multiple platform/rendering solutions with a unified codebase, providing versatility and efficiency in development.</p>\n<p>In addition to these, there are other notable templates and frameworks in the Vue.js ecosystem, each offering unique features and benefits to cater to different needs and preferences in web and application development.</p>\n<h3><strong>Brief Introduction to Nuxt.js</strong></h3>\n<p>Nuxt.js was created by French brothers Sébastien and Alexandre Chopin, with its first version released in 2016. The goal was to create a framework that simplified the development process with Vue.js, focusing particularly on server-side rendering (SSR) and automatic configuration.</p>\n<p>Nuxt.js is particularly valued for its ability to improve SEO (Search Engine Optimization) and the initial page loading performance, which are common challenges in Single Page Applications (SPAs). It simplifies the implementation of SSR by automating much of the process. This includes setting up the server, rendering Vue.js components, and managing synchronization between server and client. It also offers the capability to generate a static site. This means that all application pages are pre-rendered during the build process, generating static HTML files.</p>\n<p>From the outset, Nuxt.js was developed to complement and enhance Vue.js’s capabilities. For example, automatic routing is one of Nuxt.js’s most attractive features, eliminating the need to manually define application routes using Vue Router. During the build process, Nuxt.js automatically generates the Vue Router configuration based on the structure of the ‘pages’ directory.</p>\n<p>Nuxt.js utilizes a specific directory structure that includes pages, components, layouts, plugins, middleware, assets, and static. This structure is an integral part of Nuxt.js’s convention-over-configuration approach. Plugins are frequently used to add global libraries (like Axios for HTTP requests or Vuetify as a UI library) or to inject global functions and constants.</p>\n<h4>Applications with Strong SEO Needs</h4>\n<p>For applications that rely on good visibility in search engines, like blogs and e-commerce sites, server-side rendering (SSR) is essential. SSR ensures that the content is fully rendered on the server side, making it more easily indexable by search engines, which is crucial for SEO.</p>\n<h4>High-Performance Websites</h4>\n<p>For websites where loading performance is crucial, such as portfolios or corporate pages, static site generation offers the best solution. Static sites are faster to load and more efficient in terms of server resource usage because the HTML is pre-rendered and ready to be served instantly.</p>\n<p>Nuxt.js uses Webpack as its module bundler. During the build process, Webpack processes and packages resources such as JavaScript, Vue components, CSS, and images. This bundling is vital for optimizing application performance, as it reduces the number of requests needed to load a webpage and can include optimizations like minification and tree shaking.</p>\n<h4>Dependency Management and Versioning</h4>\n<p>Nuxt.js also adopts SemVer, and each version of Nuxt is typically built to work with a specific version of Vue.js. For instance, Nuxt.js v2 is compatible with Vue.js v2.x, while Nuxt.js v3 is designed to work with Vue.js v3. This ensures that when a developer chooses a specific version of Nuxt.js, they can be confident about which version of Vue.js it is compatible with, which is crucial for maintaining consistency and stability in application development.</p>\n<h4>Evolution of Nuxt.js: From Early to Current Versions</h4>\n<p><a href=\"https://medium.com/@nuxt_js/nuxt-js-1-0-is-out-bab1af459972\"><strong><em>Nuxt.js 1.x</em></strong></a><strong> </strong>The early versions of Nuxt.js focused on providing a framework for Vue.js applications with server-side rendering (SSR) out-of-the-box. This approach simplified the development of SSR and SPA (Single Page Application) applications, making it easier for developers to create complex, SEO-friendly web applications without dealing with the intricacies of server-side rendering configurations.</p>\n<p><a href=\"https://medium.com/@nuxt_js/nuxt-js-2-0-webpack-4-esm-modules-create-nuxt-app-and-more-6936ce80d94c\"><strong><em>Nuxt.js 2.x</em></strong></a><strong><em> </em></strong>Updates in this series brought significant improvements, such as Static Site Generation (SSG) and automatic optimization for performance. There were also advances in modularity and extensibility, with the introduction of Nuxt.js modules that could add functionality to the framework without the need for extensive manual configuration. This version made Nuxt.js more flexible and powerful, catering to a wider range of web development needs.</p>\n<p><a href=\"https://nuxt.com/docs/getting-started/installation\"><strong><em>Transition to Vue.js 3</em></strong></a> The introduction of Vue.js 3, with features like the Composition API, Proxy-based reactivity, and enhanced TypeScript support, necessitated corresponding adaptations in Nuxt.js. This led to the development and eventual release of Nuxt.js 3, which was a significant step in keeping the framework aligned with the latest Vue.js features and improvements.</p>\n<p><strong><em>Nuxt.js 3 and Beyond</em></strong><em> </em>Nuxt.js 3 was designed to leverage all the new functionalities of Vue.js 3. It offers a rewrite of the core to use the Composition API, improves support for TypeScript, and incorporates performance enhancements from the new version of Vue.js. This version represents a major leap forward in terms of developer experience, performance, and capabilities, making it a robust choice for modern web development.</p>\n<h3>Detailed Comparison</h3>\n<p>When comparing Vue.js and Nuxt.js, it’s crucial to understand that they are not direct competitors but complementary to each other. Vue.js is a progressive framework for building user interfaces, while Nuxt.js is a framework based on Vue.js, designed to simplify the development of universal (SSR) and single-page applications (SPAs).</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/631/1*rKtYy2yw9tjc6IgWLGyAmA.png\"></figure><h4>Main Use</h4>\n<ul><li>\n<strong>Vue.js</strong> is ideal for building dynamic user interfaces. <strong>Nuxt.js</strong>, being a layer on top of Vue.js, is more suitable for projects that require server-side rendering or static site generation.</li></ul>\n<h4>Routing</h4>\n<ul><li>\n<strong>Vue.js</strong> offers flexibility in routing but requires manual configuration. <strong>Nuxt.js</strong> automates this process, making routing easier based on the directory structure.</li></ul>\n<h4>SEO and Performance</h4>\n<ul><li>\n<strong>SPAs in Vue.js</strong> may face challenges with SEO due to their client-side nature. <strong>Nuxt.js</strong> addresses these issues with SSR and SSG, offering better SEO practices and faster initial loading times.</li></ul>\n<h4>Project Structure</h4>\n<ul><li>While <strong>Vue.js allows for a more flexible approach to project structuring</strong>, <strong>Nuxt.js offers a more standardized project structure</strong>, which can speed up development, especially in larger projects.</li></ul>\n<p>When evaluating Vue.js and Nuxt.js from the perspectives of <strong>scalability</strong>, <strong>maintainability</strong>, and <strong>performance</strong>, we are considering how these technologies behave as applications grow in complexity and size, and how they facilitate ongoing maintenance.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/519/1*Wa2ri_btTNzQAUmgUpiEOg.png\"></figure><h3>Nuxt.js Case Study: Large-Scale E-Commerce</h3>\n<h4>Platform Developing a robust e-commerce platform, with thousands of products, high user customization, and strict SEO and performance demands.</h4>\n<p><strong><em>Server-Side Rendering (SSR) for SEO and Performance:</em></strong> Traditional SPAs face challenges with SEO and initial load time.<strong><em> Solution:</em></strong> With native SSR, Nuxt.js significantly improves SEO and page loading speed, which is crucial for an e-commerce site.</p>\n<p><strong><em>Static Site Generation (SSG) for Product Pages:</em></strong> Maintaining performance with a large number of product pages. <strong><em>Solution:</em></strong> Using SSG, Nuxt.js can generate static pages for each product, reducing server load and improving loading speed. Project Structure and Automatic Routing.</p>\n<p><strong><em>Managing a large codebase and complex routing. Solution:</em></strong> Nuxt.js’s project structure and automatic routing simplify code organization and route management, increasing development efficiency.</p>\n<p><strong><em>Modularity and Plugins:</em> </strong>Integrating various features such as payment systems, inventory management, and user customization. <strong>Solution:</strong> The modular architecture of Nuxt.js and support for plugins allow for clean and maintainable integration of complex functionalities. Internationalization and Localization</p>\n<p><strong><em>Adapting the platform for multiple languages and regions. Solution:</em></strong> With the nuxt-i18n module, the platform can easily support multiple languages, facilitating content localization.</p>\n<h4><strong>Results and Benefits</strong></h4>\n<p><strong><em>Improved User Experience: </em></strong>The application loads quickly, even with a large amount of dynamic content, thanks to SSR and SSG.</p>\n<p><strong><em>Simplified Maintenance:</em> </strong>Maintenance is easier due to the organized structure and the ease of updates and integrations.</p>\n<p><strong><em>Assured Scalability:</em></strong> The site is able to handle an increase in traffic and product quantity without sacrificing performance.</p>\n<h3>Vue.js Case Study: Analytics Dashboard Platform</h3>\n<h4><strong>Create an interactive analytics dashboard for a medium-sized company, providing real-time insights into sales data, customer engagement, and product performance.</strong></h4>\n<p><strong><em>Rapid and Iterative Development. Solution:</em></strong> With Vue CLI, the project can be quickly bootstrapped, and Vue.js’s declarative syntax and reusable components allow for fast iterative development.</p>\n<p><strong><em>Performance and Optimization:</em></strong> Ensuring smooth performance with large volumes of data. <strong><em>Solution</em></strong>: Vue.js offers an efficient reactive system and Virtual DOM to optimize UI updates, maintaining performance even with large data volumes.</p>\n<p><strong><em>Scalability and Maintenance:</em> </strong>The application must be easy to scale and maintain.<strong><em> Solution: </em></strong>The modular and component-based architecture of Vue.js, along with an active community and excellent documentation, facilitate scalability and maintenance.</p>\n<h4>Results and Benefits</h4>\n<p><strong><em>Development Agility:</em></strong> The prototype was developed and iterated quickly, thanks to the ease of use of Vue.js.</p>\n<p><strong><em>Optimized Performance: </em></strong>The dashboard maintained high performance, even when handling and displaying data in real-time.</p>\n<h3>Guidelines for Efficient Code Architecture</h3>\n<h4>Modularity and Encapsulation</h4>\n<p><strong><em>Component-Oriented Design: </em></strong>Divide the application into smaller, independent components. This not only facilitates reuse and maintenance but also allows for more efficient testing.</p>\n<p><strong><em>Component Encapsulation:</em></strong> Use encapsulation to hide the internal complexity of components, exposing only clear and well-defined interfaces.</p>\n<h4>Clean and Separated Architecture</h4>\n<p><strong><em>Model-View-ViewModel (MVVM) Pattern: </em></strong>Separate business logic (Model), presentation layer (View), and presentation logic (ViewModel). This promotes efficient decoupling and facilitates unit testing.</p>\n<p><strong><em>Service Layer:</em></strong> Introduce a service layer to abstract business logic and interactions with external APIs or the backend.</p>\n<h4>State Management Patterns</h4>\n<p>State management patterns are crucial in frontend applications, especially as complexity and size increase. These patterns provide an organized framework for managing and maintaining application state predictably and efficiently.</p>\n<p><strong><em>Vuex </em></strong>is a state management pattern and library for Vue.js applications. It serves as a centralized store for all components in an application. Features: Deep integration with Vue’s reactivity system. Concepts of state, getters, actions, and mutations. Facilitates the maintenance and management of shared states in large Vue applications.</p>\n<p><strong><em>Pinia</em></strong> is the latest addition to the Vue.js ecosystem as an alternative to Vuex for state management. Developed with Vue 3’s Composition API in mind, Pinia offers a more intuitive and flexible state management experience. <strong><em>Stores as State Sources</em> </strong>In Pinia, each “store” is essentially a source of reactive state. Stores are lighter and more flexible compared to Vuex stores. <strong><em>Hot Module Replacement (HMR),</em></strong> meaning store state can be preserved during hot-reloading during development. Easy to Learn and Use Pinia’s framework and API are simpler and more straightforward, making it easier to learn and use, especially for new Vue developers.</p>\n<h4>Routing and Lazy Loading</h4>\n<p>Implement dynamic routing and permission-based routing to manage access to different areas of the application.</p>\n<h4>Advanced CSS Practices</h4>\n<p>Adopt methodologies like BEM, SMACSS, or OOCSS to maintain scalable and maintainable styles.</p>\n<h4>Automated Testing</h4>\n<p>Implement unit tests, integration tests, and end-to-end (E2E) tests to ensure code quality.</p>\n<h4>Linting and Code Formatting</h4>\n<p>Use tools like ESLint and Prettier to maintain code consistency and identify potential issues early on.</p>\n<blockquote>An efficient code architecture in frontend projects requires a holistic approach that encompasses everything from component structure to advanced state management practices and performance optimization. These guidelines are essential for creating scalable, efficient, and easy-to-maintain applications, suitable for the complex needs of web development.</blockquote>\n<h3>Tips for optimizing code performance and maintenance: Strategies to keep code clean and performant</h3>\n<h4>Clean Code Principles</h4>\n<p><strong><em>Readability:</em> </strong>Write code as if it were a book. This includes descriptive variable and function names, as well as a clear logical structure.</p>\n<p><strong><em>Simplicity: </em></strong>Avoid unnecessary complexity. Simpler solutions are often easier to maintain.</p>\n<p><strong><em>DRY (Don’t Repeat Yourself): </em></strong>Eliminate code repetition. Reuse code whenever possible to reduce duplication and ease future changes.</p>\n<p><strong><em>Efficient State Management (</em></strong><em>Local vs. Global State): </em>Carefully assess the need for global state. Use local state whenever possible to reduce complexity.</p>\n<p><strong><em>Caching and Memoization: </em></strong>Implement caching and memoization for heavy operations, such as API queries or complex calculations.</p>\n<h3>Conclusion</h3>\n<h4>Features and Practices</h4>\n<p><strong>Vue.js — Flexibility and Intuitiveness: </strong>Vue.js is ideal for SPAs and dynamic user interfaces, known for its smooth learning curve, componentization, and efficient reactivity.</p>\n<p><strong>Nuxt.js — Structure and Optimization: </strong>Nuxt.js extends Vue.js capabilities, offering standardized structures and additional features like SSR and SSG, ideal for projects requiring enhanced SEO and performance.</p>\n<p><strong>Design Patterns and Code Architecture: </strong>Adopting clear design patterns and efficient code architecture, such as modularity, encapsulation, and state management, is crucial for scalability and maintainability.</p>\n<h3><strong>Choosing between Vue.js and Nuxt.js for a specific project depends on various factors related to the project’s needs and objectives. Here are some final guidelines to help make this decision:</strong></h3>\n<h4>Considering the Scope and Project Requirements</h4>\n<p><strong>Vue.js: </strong>Ideal for projects that require a flexible and customizable approach, such as Single Page Applications (SPAs) or when integrating Vue into an existing project.</p>\n<p><strong>Nuxt.js:</strong> Better suited for projects that benefit from Server-Side Rendering (SSR) or Static Site Generation (SSG), such as applications that need improved SEO and better initial loading performance.</p>\n<h4>Evaluating Team Experience and Available Resources</h4>\n<p><strong>Learning Curve: </strong>Teams already familiar with Vue.js will find it easy to adopt Nuxt.js, but for those who are new to both, Vue.js can be a more accessible starting point due to its smoother learning curve.</p>\n<p><strong>Resources and Community:</strong> Both have active communities and a good number of available resources. Considering community support and resources can be crucial, especially for smaller teams or projects with limited budgets.</p>\n<h4>SEO and Performance</h4>\n<p>If SEO and initial loading performance are priorities, Nuxt.js with its integrated SSR and SSG is the most suitable choice.</p>\n<h4>Flexibility vs. Convention</h4>\n<p><strong>Vue.js: </strong>Offers greater flexibility in structuring the project. <strong>Nuxt.js:</strong> Provides directory structure conventions that can speed up development and ensure consistency, especially useful in larger teams or projects with many developers.</p>\n<p><em>The choice between Vue.js and Nuxt.js should be based on a careful assessment of the project’s specific needs, available resources, and the development team’s experience. Vue.js is better suited for projects that require a flexible and customizable approach, while Nuxt.js is ideal for projects that need advanced features like SSR and SSG for SEO and performance. Evaluating these factors will help ensure that the chosen technology aligns with the project’s goals and requirements, maximizing development efficiency and success.</em></p>\n<blockquote>Feel free to <a href=\"https://www.linkedin.com/in/leticiamirelly/\">connect with me on LinkedIn</a> for any further discussions or questions you may have. Happy coding!</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=26ff459f0f74\" width=\"1\" height=\"1\" alt=\"\">\n",
			"enclosure": {},
			"categories": [
				"nuxtjs",
				"clean-code",
				"vuejs",
				"vue",
				"front-end-development"
			]
		},
		{
			"title": "A Comprehensive Guide to npm Workspaces and Monorepos",
			"pubDate": "2023-12-30 14:42:30",
			"link": "https://leticia-mirelly.medium.com/a-comprehensive-guide-to-npm-workspaces-and-monorepos-ce0cdfe1c625?source=rss-7deace8b3a8e------2",
			"guid": "https://medium.com/p/ce0cdfe1c625",
			"author": "Leticia Mirelly ϟ",
			"thumbnail": "",
			"description": "\n<h3>A little about current workspace managers</h3>\n<a href=\"https://medium.com/media/86b9287d3e6c7c18976c8b8921174338/href\">https://medium.com/media/86b9287d3e6c7c18976c8b8921174338/href</a><h4>Yarn Classic x Yarn Berry Workspaces</h4>\n<p><strong>Dependency Resolution:</strong> Yarn classic workspaces use a “pluggable” resolution algorithm, providing more flexibility in how dependencies are resolved. Like npm, Yarn uses hoisting to share common dependencies at the root level, unlike Yarn Berry, which has a new architecture with a “plug’n’play” resolution strategy, aiming for a zero-installation approach. It takes advantage of the concept of “PnP” files to represent dependencies without the need for a traditional node_modules directory. This is a complex choice if you want to migrate managers later because Yarn Berry eliminates the need for a central node_modules leading to faster and more efficient installations however brings significant changes in how dependencies are resolved.</p>\n<h4><strong>Npm Workspaces</strong></h4>\n<p><strong>Dependency Resolution: </strong>npm workspaces utilize a “fixed” strategy for dependency resolution. Each workspace has its own node_modules, and dependencies are installed per workspace. However, common dependencies are hoisted to the root node_modules to optimize disk space.</p>\n<p><strong>Established Ecosystem Integration:</strong> Being the default package manager for Node.js, npm seamlessly integrates with the broader Node.js ecosystem.</p>\n<p><strong>Share Dependencies: </strong>npm Workspaces enable the sharing of dependencies between packages. If multiple packages require the same dependency, it can be installed once at the workspace level, optimizing disk space and simplifying dependency management.</p>\n<h3>Hands-on with npm workspace</h3>\n<h4>Setup Project</h4>\n<pre>mkdir your-project &amp;&amp; cd your-project &amp;&amp; npm init -y</pre>\n<h4>Parent Workspace Configuration (root package.json)</h4>\n<pre>{<br>  \"name\": \"my-monorepo\",<br>  \"workspaces\": [<br>    \"packages/*\"<br>  ],<br>// Example of shared scripts in workspaces<br>{<br>  \"scripts\": {<br>    \"build\": \"npm run build:package-a &amp;&amp; npm run build:package-b\",<br>    \"build:package-a\": \"cd packages/package-a &amp;&amp; npm run build\",<br>    \"build:package-b\": \"cd packages/package-b &amp;&amp; npm run build\"<br>  }<br>}<br>}</pre>\n<h4>Directory Structure</h4>\n<pre>/my-monorepo<br>|-- /packages<br>|   |-- /package-a<br>|   |-- /package-b<br>|-- package.json</pre>\n<h4>Package A</h4>\n<pre>// /packages/package-a/package.json<br>{<br>  \"name\": \"package-a\",<br>  \"version\": \"1.0.0\",<br>  \"main\": \"index.js\",<br>  \"scripts\": {<br>    \"test\": \"echo \\\"Error: run tests from root\\\" &amp;&amp; exit 1\"<br>  }<br>}</pre>\n<pre>// /packages/package-a/index.js<br>module.exports = () =&gt; {<br>  console.log('Hello from Package A!');<br>};</pre>\n<h4>Package B</h4>\n<pre>// /packages/package-b/package.json<br>{<br>  \"name\": \"package-b\",<br>  \"version\": \"1.0.0\",<br>  \"main\": \"index.js\",<br>  \"dependencies\": {<br>    \"package-a\": \"1.0.0\"<br>  },<br>  \"scripts\": {<br>    \"test\": \"echo \\\"Error: run tests from root\\\" &amp;&amp; exit 1\"<br>  }<br>}</pre>\n<pre>// /packages/package-b/index.js<br>const packageA = require('package-a');<br><br>module.exports = () =&gt; {<br>  packageA();<br>  console.log('Hello from Package B!');<br>};</pre>\n<h3>npm link in Workspaces:</h3>\n<h4><strong>Local Development and Testing:</strong></h4>\n<p>npm link</p>\n<p>is a powerful tool in the npm ecosystem, allowing packages to be symlinked for local development. In the context of npm workspaces, this tool can be used to connect packages within the workspace for seamless local development and testing.</p>\n<h4><strong>Mechanism:</strong></h4>\n<p>npm ensures that when using npm link, the linked package is correctly hoisted to the top-level node_modules directory, maintaining the integrity of the workspace structure. After running the above command, package-a will be symlinked and hoisted to the top-level node_modules, allowing seamless development.</p>\n<pre># Example npm link in workspaces<br>cd packages/package-a<br>npm link<br>cd ../package-b<br>npm link package-a</pre>\n<p>After setting up the structure, running npm install in the root directory installs all dependencies for all packages, linking them where necessary.</p>\n<h3>Helpful Commands for Reference</h3>\n<h4><strong>Installing Workspace Dependencies</strong></h4>\n<p>Install dependencies for all packages defined in the workspace configuration.</p>\n<pre>npm install</pre>\n<h4>Scopes and Private Packages in Workspaces</h4>\n<ul><li>Scopes (@scope/package) can also be used in workspaces, and the logic of private scopes still applies.</li></ul>\n<pre># Example of installation in workspaces with private scope<br>npm install @scope/package-a --workspace</pre>\n<h4>Listing Dependencies Across Workspaces</h4>\n<p>List dependencies across all workspaces.</p>\n<pre>npm ls</pre>\n<h3>Hoisting in npm Workspaces</h3>\n<p>In npm workspaces, hoisting plays a crucial role in optimizing the installation and management of dependencies across multiple packages within the same workspace.</p>\n<h4>Common Dependencies</h4>\n<ul><li>When multiple packages within a workspace depend on the same package and version, npm hoists that dependency to the top-level node_modules directory. This means that instead of having duplicate copies of the same dependency in each package's node_modules, there's a single shared instance at the root.</li></ul>\n<pre>// Example workspace package.json<br>{<br>  \"workspaces\": [\"packages/*\"],<br>  \"dependencies\": {<br>    \"lodash\": \"^4.17.21\"<br>  }<br>}</pre>\n<p>If two packages within the workspace use lodash, npm ensures that only one copy of lodash is present at the top-level node_modules directory.</p>\n<h4>Scoped Packages</h4>\n<ul><li>For scoped packages, hoisting also occurs within the scoped directory, further optimizing the organization of dependencies.</li></ul>\n<pre>// Example workspace package.json with scoped package<br>{<br>  \"workspaces\": [\"packages/*\"],<br>  \"dependencies\": {<br>    \"@my-monorepo/package-a\": \"^1.0.0\"<br>  }<br>}</pre>\n<p>The scoped package, in this case, will be hoisted to the top-level node_modules/@my-scope/package-a directory.</p>\n<h3>Benefits of Hoisting in npm Workspaces:</h3>\n<p><strong>Disk Space Efficiency</strong></p>\n<p>By hoisting common dependencies, npm workspaces optimize disk space usage, as there’s only one copy of a dependency shared among multiple packages.</p>\n<p><strong>Faster Installations</strong></p>\n<p>Hoisting reduces the time it takes to install dependencies, as npm can avoid redundant installations and copy operations.</p>\n<p><strong>Consistent Dependency Versions:</strong></p>\n<p>Hoisting ensures that all packages within the workspace use the same version of a dependency, avoiding version conflicts.</p>\n<h3>Conclusion</h3>\n<p>While it is feasible to manage tasks at the individual workspace level, centralizing shared responsibilities at the root level fosters a more coherent and straightforward approach. Embracing npm Workspaces can significantly improve monorepo management, fostering enhanced collaboration, modularity, and overall development efficiency. However, the choice between npm Workspaces, Yarn Workspaces, and Yarn Berry hinges on considerations such as ecosystem familiarity, project requirements, and personal preferences. Each of these tools possesses unique strengths, and the decision should be carefully aligned with the specific needs and objectives of the project.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ce0cdfe1c625\" width=\"1\" height=\"1\" alt=\"\">\n",
			"content": "\n<h3>A little about current workspace managers</h3>\n<a href=\"https://medium.com/media/86b9287d3e6c7c18976c8b8921174338/href\">https://medium.com/media/86b9287d3e6c7c18976c8b8921174338/href</a><h4>Yarn Classic x Yarn Berry Workspaces</h4>\n<p><strong>Dependency Resolution:</strong> Yarn classic workspaces use a “pluggable” resolution algorithm, providing more flexibility in how dependencies are resolved. Like npm, Yarn uses hoisting to share common dependencies at the root level, unlike Yarn Berry, which has a new architecture with a “plug’n’play” resolution strategy, aiming for a zero-installation approach. It takes advantage of the concept of “PnP” files to represent dependencies without the need for a traditional node_modules directory. This is a complex choice if you want to migrate managers later because Yarn Berry eliminates the need for a central node_modules leading to faster and more efficient installations however brings significant changes in how dependencies are resolved.</p>\n<h4><strong>Npm Workspaces</strong></h4>\n<p><strong>Dependency Resolution: </strong>npm workspaces utilize a “fixed” strategy for dependency resolution. Each workspace has its own node_modules, and dependencies are installed per workspace. However, common dependencies are hoisted to the root node_modules to optimize disk space.</p>\n<p><strong>Established Ecosystem Integration:</strong> Being the default package manager for Node.js, npm seamlessly integrates with the broader Node.js ecosystem.</p>\n<p><strong>Share Dependencies: </strong>npm Workspaces enable the sharing of dependencies between packages. If multiple packages require the same dependency, it can be installed once at the workspace level, optimizing disk space and simplifying dependency management.</p>\n<h3>Hands-on with npm workspace</h3>\n<h4>Setup Project</h4>\n<pre>mkdir your-project &amp;&amp; cd your-project &amp;&amp; npm init -y</pre>\n<h4>Parent Workspace Configuration (root package.json)</h4>\n<pre>{<br>  \"name\": \"my-monorepo\",<br>  \"workspaces\": [<br>    \"packages/*\"<br>  ],<br>// Example of shared scripts in workspaces<br>{<br>  \"scripts\": {<br>    \"build\": \"npm run build:package-a &amp;&amp; npm run build:package-b\",<br>    \"build:package-a\": \"cd packages/package-a &amp;&amp; npm run build\",<br>    \"build:package-b\": \"cd packages/package-b &amp;&amp; npm run build\"<br>  }<br>}<br>}</pre>\n<h4>Directory Structure</h4>\n<pre>/my-monorepo<br>|-- /packages<br>|   |-- /package-a<br>|   |-- /package-b<br>|-- package.json</pre>\n<h4>Package A</h4>\n<pre>// /packages/package-a/package.json<br>{<br>  \"name\": \"package-a\",<br>  \"version\": \"1.0.0\",<br>  \"main\": \"index.js\",<br>  \"scripts\": {<br>    \"test\": \"echo \\\"Error: run tests from root\\\" &amp;&amp; exit 1\"<br>  }<br>}</pre>\n<pre>// /packages/package-a/index.js<br>module.exports = () =&gt; {<br>  console.log('Hello from Package A!');<br>};</pre>\n<h4>Package B</h4>\n<pre>// /packages/package-b/package.json<br>{<br>  \"name\": \"package-b\",<br>  \"version\": \"1.0.0\",<br>  \"main\": \"index.js\",<br>  \"dependencies\": {<br>    \"package-a\": \"1.0.0\"<br>  },<br>  \"scripts\": {<br>    \"test\": \"echo \\\"Error: run tests from root\\\" &amp;&amp; exit 1\"<br>  }<br>}</pre>\n<pre>// /packages/package-b/index.js<br>const packageA = require('package-a');<br><br>module.exports = () =&gt; {<br>  packageA();<br>  console.log('Hello from Package B!');<br>};</pre>\n<h3>npm link in Workspaces:</h3>\n<h4><strong>Local Development and Testing:</strong></h4>\n<p>npm link</p>\n<p>is a powerful tool in the npm ecosystem, allowing packages to be symlinked for local development. In the context of npm workspaces, this tool can be used to connect packages within the workspace for seamless local development and testing.</p>\n<h4><strong>Mechanism:</strong></h4>\n<p>npm ensures that when using npm link, the linked package is correctly hoisted to the top-level node_modules directory, maintaining the integrity of the workspace structure. After running the above command, package-a will be symlinked and hoisted to the top-level node_modules, allowing seamless development.</p>\n<pre># Example npm link in workspaces<br>cd packages/package-a<br>npm link<br>cd ../package-b<br>npm link package-a</pre>\n<p>After setting up the structure, running npm install in the root directory installs all dependencies for all packages, linking them where necessary.</p>\n<h3>Helpful Commands for Reference</h3>\n<h4><strong>Installing Workspace Dependencies</strong></h4>\n<p>Install dependencies for all packages defined in the workspace configuration.</p>\n<pre>npm install</pre>\n<h4>Scopes and Private Packages in Workspaces</h4>\n<ul><li>Scopes (@scope/package) can also be used in workspaces, and the logic of private scopes still applies.</li></ul>\n<pre># Example of installation in workspaces with private scope<br>npm install @scope/package-a --workspace</pre>\n<h4>Listing Dependencies Across Workspaces</h4>\n<p>List dependencies across all workspaces.</p>\n<pre>npm ls</pre>\n<h3>Hoisting in npm Workspaces</h3>\n<p>In npm workspaces, hoisting plays a crucial role in optimizing the installation and management of dependencies across multiple packages within the same workspace.</p>\n<h4>Common Dependencies</h4>\n<ul><li>When multiple packages within a workspace depend on the same package and version, npm hoists that dependency to the top-level node_modules directory. This means that instead of having duplicate copies of the same dependency in each package's node_modules, there's a single shared instance at the root.</li></ul>\n<pre>// Example workspace package.json<br>{<br>  \"workspaces\": [\"packages/*\"],<br>  \"dependencies\": {<br>    \"lodash\": \"^4.17.21\"<br>  }<br>}</pre>\n<p>If two packages within the workspace use lodash, npm ensures that only one copy of lodash is present at the top-level node_modules directory.</p>\n<h4>Scoped Packages</h4>\n<ul><li>For scoped packages, hoisting also occurs within the scoped directory, further optimizing the organization of dependencies.</li></ul>\n<pre>// Example workspace package.json with scoped package<br>{<br>  \"workspaces\": [\"packages/*\"],<br>  \"dependencies\": {<br>    \"@my-monorepo/package-a\": \"^1.0.0\"<br>  }<br>}</pre>\n<p>The scoped package, in this case, will be hoisted to the top-level node_modules/@my-scope/package-a directory.</p>\n<h3>Benefits of Hoisting in npm Workspaces:</h3>\n<p><strong>Disk Space Efficiency</strong></p>\n<p>By hoisting common dependencies, npm workspaces optimize disk space usage, as there’s only one copy of a dependency shared among multiple packages.</p>\n<p><strong>Faster Installations</strong></p>\n<p>Hoisting reduces the time it takes to install dependencies, as npm can avoid redundant installations and copy operations.</p>\n<p><strong>Consistent Dependency Versions:</strong></p>\n<p>Hoisting ensures that all packages within the workspace use the same version of a dependency, avoiding version conflicts.</p>\n<h3>Conclusion</h3>\n<p>While it is feasible to manage tasks at the individual workspace level, centralizing shared responsibilities at the root level fosters a more coherent and straightforward approach. Embracing npm Workspaces can significantly improve monorepo management, fostering enhanced collaboration, modularity, and overall development efficiency. However, the choice between npm Workspaces, Yarn Workspaces, and Yarn Berry hinges on considerations such as ecosystem familiarity, project requirements, and personal preferences. Each of these tools possesses unique strengths, and the decision should be carefully aligned with the specific needs and objectives of the project.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ce0cdfe1c625\" width=\"1\" height=\"1\" alt=\"\">\n",
			"enclosure": {},
			"categories": []
		}
	]
}