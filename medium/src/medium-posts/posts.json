{
	"status": "ok",
	"feed": {
		"url": "https://medium.com/feed/@leticia-mirelly",
		"title": "Stories by Leticia Mirelly ÏŸ on Medium",
		"link": "https://medium.com/@leticia-mirelly?source=rss-7deace8b3a8e------2",
		"author": "",
		"description": "Stories by Leticia Mirelly ÏŸ on Medium",
		"image": "https://cdn-images-1.medium.com/fit/c/150/150/1*B_p9l2m61TLynuXPBGv-qw.jpeg"
	},
	"items": [
		{
			"title": "Construa uma vez, escale por anosâ€Šâ€”â€ŠAplicaÃ§Ãµes front-end que nascem para durar.",
			"pubDate": "2024-07-06 16:17:11",
			"link": "https://leticia-mirelly.medium.com/construa-uma-vez-escale-por-anos-aplica%C3%A7%C3%B5es-front-end-que-nascem-para-durar-1c9d63242d21?source=rss-7deace8b3a8e------2",
			"guid": "https://medium.com/p/1c9d63242d21",
			"author": "Leticia Mirelly ÏŸ",
			"thumbnail": "",
			"description": "\n<h3>Construa uma vez, escale por anosâ€Šâ€”â€ŠAplicaÃ§Ãµes front-end que nascem paraÂ durar.</h3>\n<a href=\"https://medium.com/media/e6590a4ef3722310fdbf785bde4228c5/href\">https://medium.com/media/e6590a4ef3722310fdbf785bde4228c5/href</a><p>Muitas decisÃµes de negÃ³cios ainda priorizam a velocidade de entrega em detrimento da qualidade do desenvolvimento de software, resultando em consequÃªncias desastrosas. Dentre os exemplos mais recentes, em 2022, <a href=\"https://www.nytimes.com/2022/12/31/opinion/southwest-airlines-computers.html\">o sistema de agendamento de tripulaÃ§Ãµes da Southwest Airlines</a> nÃ£o conseguiu lidar com interrupÃ§Ãµes inesperadas no clima de inverno, levando a muitos cancelamentos de voos e perdas financeiras de aproximadamente 410 milhÃµes de dÃ³lares. Outro exemplo Ã© o dos voos Lion Air 610 e Ethiopian Airlines 302, ambos envolvendo aeronaves <a href=\"https://www.rollingstone.com/culture/culture-features/boeing-737-max-disasters-timeline-1235007089/\">Boeing 737 Max</a>, que tiveram parte do problema atribuÃ­da a falhas no software do sistema de controle de voo (MCAS) e na documentaÃ§Ã£o.</p>\n<h4>As perguntas que tentarei responder sÃ£o: Como evidenciar o impacto comercial e financeiro na performance evolutiva de uma aplicaÃ§Ã£o a medida que ela cresce e quais as pontas gerir para nÃ£o cair no dilema das â€œ<a href=\"https://pt.wikipedia.org/wiki/Teoria_das_janelas_quebradas\">janelas quebradas</a>â€.</h4>\n<p>Esse Ã© um tema pretensioso, eu sei. Como desenvolvedora jÃ¡ trabalhei em alguns projetos legados, projetos com ciclos de vida enormes e fui â€œmÃ£eâ€ de outros, sempre questionei a fundo sobre o que aquela aplicaÃ§Ã£o viria a se tornar a nÃ­vel de escopo, entretanto essa Ã© sempre uma grande variÃ¡vel que custa a ser mensurada. Acredito fazer sentido responder algo pretensioso assim com um punhado de referÃªncias externas e pessoais a fim de documentar estudos e experiÃªncias.</p>\n<p><em>Algumas palavras preferi manter em InglÃªs ao invÃ©s de traduzi-las, acredito ser mais proveitoso e eficaz manter como sÃ£o comumente conhecidas.</em></p>\n<p>Com base no estudo <a href=\"https://arxiv.org/abs/2203.04374\">Code Red: The Business Impact of Code Quality</a>, 39 bases de cÃ³digos de produÃ§Ã£o foram analisados com 30.737 arquivos se baseando na mÃ©trica de Code Health da CodeScene como um proxy para qualidade de cÃ³digo considerando a anÃ¡lise de cÃ³digo-fonte, mineraÃ§Ã£o de controle de versÃ£o e informaÃ§Ãµes de emissÃ£o do Jira foi percebido que cÃ³digo de baixa qualidade contÃ©m 15 vezes mais defeitos do que o cÃ³digo de alta qualidade e cÃ³digos de baixa qualidade leva em mÃ©dia 124% mais tempo de desenvolvimento. O estudo evidencia ainda que atÃ© 42% do tempo dos desenvolvedores Ã© desperdiÃ§ado lidando com dÃ­vidas tÃ©cnicas, custando uma mÃ©dia de US$ 85 bilhÃµes por ano. HÃ¡ uma ponte a ser construÃ­da entre o time que realiza a entrega e o time comercial, com 15x menos defeitos e com mais previsibilidade do tempo de desenvolvimento e entrega, a vantagem competitiva de produzir cÃ³digo de qualidade de forma sustentÃ¡vel a longo prazo e com curto time-to-market torna-seÂ clara.</p>\n<p>Infelizmente essa ainda nÃ£o Ã© uma visÃ£o amplamente abraÃ§ada pela Ã¡rea de negÃ³cio porque muitas vezes nÃ£o hÃ¡ clareza de benefÃ­cios quantificÃ¡veis em pagar por refatoraÃ§Ãµes por isso os gestores nÃ£o concedem o orÃ§amento e prioridade necessÃ¡rias e acabam negociando as entregas levando em conta o curto prazo muitas vezes chegando no viÃ©s da tomada de decisÃ£o <em>desconto hiperbÃ³lico</em>, onde seus eus futuros lidam com as consequÃªncias de escolhas que prefeririam nÃ£o te-lasÂ feito.</p>\n<h3><strong>KPIs da qualidade de software: idiotas da objetividade?</strong></h3>\n<p>Embora existam muitas pesquisas concentradas em nortear a qualidade de software nÃ£o se pode declarar a mesma soluÃ§Ã£o para todas as aplicaÃ§Ãµes, entretanto podemos usar ferramentas e mÃ©todos tangÃ­veis. Essas ferramentas sÃ£o o comeÃ§o, e nÃ£o o fim, de como tangibilizar e negociar dÃ©bitos tÃ©cnicos com os gestores.</p>\n<h4>Gerenciar a DÃ­vidaÂ tÃ©cnica</h4>\n<a href=\"https://medium.com/media/523d0736ba1ed8bea0818da53353b981/href\">https://medium.com/media/523d0736ba1ed8bea0818da53353b981/href</a><p>A teoria teoria das janelas quebradas, emprestada da criminologia e aplicada no contexto do desenvolvimento de software (William LevÃ©n, <a href=\"https://arxiv.org/pdf/2209.01549\">2023</a> ), trata da relaÃ§Ã£o causal entre a quantidade de dÃ©bitos tÃ©cnicos de uma aplicaÃ§Ã£o e a propensÃ£o dos desenvolvedores inserirem novos dÃ©bitos tÃ©cnicos Ã  medida que a aplicaÃ§Ã£o cresce. Avaliando fatores psicolÃ³gicos, o comportamento Ã© moldado por uma norma descritiva, onde o comportamento torna-se ser aceitÃ¡vel. Dentre alguns insights alarmantes estÃ¡ a ligaÃ§Ã£o entre DT e a propensÃ£o Ã  vulnerabilidade da aplicaÃ§Ã£o incluindo riscos de seguranÃ§a.</p>\n<p><strong>Tipos de dÃ­vidaÂ tÃ©cnica:</strong></p>\n<ul>\n<li>\n<strong>Qualidade do cÃ³digo: </strong>Baixa manutenibilidade, padrÃµes de cÃ³digo inexistentes, mal projetado e muito complexo.</li>\n<li><strong>Baixa cobertura de cÃ³digo e de teste automatizado.</strong></li>\n<li><strong>Bibliotecas e/ou ferramentas desatualizadas/legadas.</strong></li>\n<li><strong>Arquitetura errada ou inexistente.</strong></li>\n<li><strong>Falta de documentaÃ§Ã£o.</strong></li>\n<li><strong>Defeitos/Bugs.</strong></li>\n<li><strong>Entre outros como por exemplo processo manual deÂ CI/CD.</strong></li>\n</ul>\n<p>Para gerenciar eficazmente hÃ¡ algumas etapas como: 1) <strong>identificar as dÃ­vidas,</strong> 2) <strong>Torna-las visÃ­veis,</strong> 3) <strong>Implementar mudanÃ§as e mitigar os efeitos daÂ dÃ­vida.</strong></p>\n<h4><strong>Dando nome Ã s dÃ­vidasÂ tÃ©cnicas</strong></h4>\n<p>De forma prÃ¡tica, hÃ¡ algumas ferramentas de analise automÃ¡tica parcial do cÃ³digo como SonarQube que identifica violaÃ§Ãµes de prÃ¡ticas de codificaÃ§Ã£o e calcula o custo de refatoraÃ§Ã£o de cada dÃ­vida. HÃ¡ ainda dÃ­vidas que nÃ£o sÃ£o encontradas por ferramentas de analise automatizada mas sÃ£o conhecidas pelo time de desenvolvimento, Ã© aconselhÃ¡vel mante-las juntamente com dÃ­vidas fornecidas por uma ferramenta em um backlog tÃ©cnico com a descriÃ§Ã£o do que deverÃ¡ ser feito e estimativa para resolver.</p>\n<h4><strong>Mapa de dÃ©bitosÂ tÃ©cnicos</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*QLDIMgUxwMsz6545GWF4Qg.jpeg\"></figure><p>Esse mapa foi tirado do <a href=\"https://blog.thepete.net/blog/2020/12/01/tech-debt-walls/\">artigo publicado por Pete HogsonÂ </a>, onde as dÃ­vidas sÃ£o colocadas em duas dimensÃµes de <strong>custo</strong> e <strong>valor</strong>. Em suas palavras, Os problemas na Ã¡rea inferior esquerda do muro sÃ£o â€œvitÃ³rias rÃ¡pidasâ€â€Šâ€”â€Šo tipo de cortesia que vocÃª pode receber se quiser limpar um pouco o acampamento em uma tarde tranquila de sexta-feira. Problemas na Ã¡rea superior esquerda do muro sÃ£o â€œfÃ¡ceis de resolverâ€â€Šâ€”â€Štrabalho de baixo custo e alto valor que deve ser resolvido em breve. Por outro lado, problemas na Ã¡rea inferior direita do quadro sÃ£o os itens â€œnÃ£oâ€. O investimento simplesmente nÃ£o vale a pena quando se trata desses problemas. O restante do muro contÃ©m â€œinvestimentos valiososâ€â€Šâ€”â€Šitens de dÃ­vida que provavelmente fornecerÃ£o um bom retorno sobre o investimento, mas tambÃ©m sÃ£o substanciais o suficiente para exigir negociaÃ§Ã£o com outras partes interessadas para serem priorizados.</p>\n<h4><strong>O que fazer com essas informaÃ§Ãµes?</strong></h4>\n<p><a href=\"https://www.computer.org/\">Frank Buscgmann cita 3 estratÃ©gias:</a></p>\n<ul>\n<li>\n<strong>Pague a dÃ­vida: </strong>Refatorar ou substituir oÂ cÃ³digo.</li>\n<li>\n<strong>ConversÃ£o de dÃ­vida: </strong>Substitua a soluÃ§Ã£o atual por uma soluÃ§Ã£o â€œboa, mas nÃ£o perfeitaâ€.</li>\n<li>\n<strong>Pague apenas os juros: </strong>Viva com o cÃ³digo, porque a refatoraÃ§Ã£o Ã© mais cara do que trabalhar com o cÃ³digo nÃ£o muitoÂ correto.</li>\n</ul>\n<blockquote>\n<strong><em>A refatoraÃ§Ã£o substancial Ã© sempre uma decisÃ£o de negÃ³cios(Wolff, </em></strong><a href=\"https://www.infoq.com/articles/managing-technical-debt/\"><strong><em>2013</em></strong></a><strong><em>)</em></strong>\n</blockquote>\n<h4>Modelo de criaÃ§Ã£o deÂ valor</h4>\n<p>Uma analise aprofundada sobre o retorno do investimento em esforÃ§os de refatoraÃ§Ã£o Ã© dada no modelo de criaÃ§Ã£o de valor (<a href=\"https://arxiv.org/html/2401.13407v1#abstract\">2024, </a>Markus Borg) e SPACE framework que mensura a <strong>capacidade</strong> e <strong>eficiÃªncia</strong> do time de desenvolvimento. O modelo de criaÃ§Ã£o de valor concentra-se em modelos de regressÃ£o para identificar a relaÃ§Ã£o entre Code Health e duas variÃ¡veis que dependem entre si: 1) nÃºmero mÃ©dio de defeitos e 2) tempo mÃ©dio de Desvio, evidenciando como retorno da analise o impacto de mudanÃ§as relativas na qualidade do cÃ³digo-fonte.</p>\n<p><strong>Capacidade</strong> mÃ¡xima que a organizaÃ§Ã£o pode alcanÃ§ar em condiÃ§Ãµes ideais. Maior capacidade == mais tempo de codificaÃ§Ã£o;</p>\n<p><strong>EficiÃªncia</strong> Ã© a capacidade convertida em valor real. Maior eficiÃªncia menos interrupÃ§Ã£o.</p>\n<p><strong>ğ‘¢</strong> = <strong>fraÃ§Ã£o de trabalho nÃ£o planejado</strong></p>\n<p>EficiÃªncia = (1â€Šâ€”â€Š<strong>ğ‘¢</strong>)</p>\n<blockquote>v = c Ã— ( 1 âˆ’ ğ‘¢Â )</blockquote>\n<p>Considera-se tambÃ©m duas proporcionalidades: A primeira Ã© que <em>a capacidade Ã© inversamente proporcional ao Time-in-Dev.</em></p>\n<blockquote>Quanto mais os desenvolvedores trabalham na implementaÃ§Ã£o de uma resoluÃ§Ã£o, mais recursos sÃ£o amarrados para lidar com ela. Esses recursos poderiam, em vez disso, ter sido alocados para o desenvolvimento de novos recursos que contribuem diretamente para a capacidade de desenvolvimento.</blockquote>\n<p>E em segundo lugar,<em> </em><strong><em>a fraÃ§Ã£o de trabalho nÃ£o planejado Ã© proporcional ao nÃºmero de defeitos.</em></strong></p>\n<p>Embora tenha se verificado uma nÃ£o linearidade total entre Code Health e criaÃ§Ã£o de valor os resultados da pesquisa sugeremÂ que:</p>\n<ul>\n<li>As funÃ§Ãµes tÃ©cnicas devem comunicar melhor os benefÃ­cios aos nÃ­veis executivos para informar as decisÃµes estratÃ©gicas de refatoraÃ§Ã£o.</li>\n<li>Evitar diligentemente cheiros de cÃ³digo em arquivos onde a taxa de juros sobre a dÃ­vida tÃ©cnica Ã© alta, ou seja, arquivos com rotatividade substancial.</li>\n<li>Os desenvolvedores resolvem problemas rapidamenteâ€Šâ€”â€Še possivelmente de forma imprudenteâ€Šâ€”â€Šse a qualidade do cÃ³digo jÃ¡ forÂ pÃ©ssima.</li>\n</ul>\n<h3>Mais afundoâ€Šâ€”â€ŠAmarrando asÂ pontas</h3>\n<p><em>NÃ£o pretendo aprofundar na escolha da stack, poderia escrever um artigo somente sobre isso se for desejÃ¡vel, me deixe saber nos comentÃ¡rios.</em></p>\n<blockquote>if youâ€™re afraid to change something it is clearly poorly designed.<br>â€Šâ€”â€ŠMartinÂ Fowler</blockquote>\n<h4>High-level architecture</h4>\n<p>Arquitetura Ã© a forma como as unidades da aplicaÃ§Ã£o interagem entre si, aqui a preocupaÃ§Ã£o Ã© mais a nÃ­vel estrutural do que a detalhes de implementaÃ§Ã£o e/ou tecnologias de suporte. A arquitetura Ã© guiada pelo domÃ­nio e casos deÂ uso.</p>\n<p>Resolver questÃµes complexas na construÃ§Ã£o de aplicaÃ§Ãµes front-end tem se tornado mais simples mas nÃ£o mais fÃ¡cil, isso porque as arquiteturas mudaram muito nos Ãºltimos 30 anos Ã  medida que o clÃ¡ssico Model View Control (MVC) evoluÃ­a para dar entrada Ã  novas estruturas mais modernas. Curioso perceber que mesmo as estruturas mais atuais foram construÃ­das em estruturas jÃ¡ existentes adicionando melhorias continuas.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*tao7a30JsPeaYv01ijFhTg.png\"><figcaption>Imagem do livro front-end reactive architectures</figcaption></figure><p><em>De antemÃ£o, nÃ£o hÃ¡ razÃµes determinÃ­sticas que orientem a arquitetura por um viÃ©s padrÃ£o Ã  todas, nenhuma arquitetura Ã© boa em si mesmo, o mesmo serve para a escolha da stack, a mais â€œhypadaâ€ nÃ£o deveria ser escolhida por este motivo tambÃ©m, a escolha se baseia na necessidade do produto e doÂ negÃ³cio.</em></p>\n<p>Na prÃ¡tica, representar os requisitos do software sÃ£o de maior peso na balanÃ§a, eles podem mudar todo o cenÃ¡rio, um exemplo clÃ¡ssico Ã© a <a href=\"https://gustafnk.github.io/microservice-websites/\">IKEA</a> que devido ao contexto do produto decidiram implementar 2 tÃ©cnicas: 1) Fragmentos autocontidos (SCS) em uma arquitetura micro front-end que atende a demandas de equipes diferentes com funcionalidades compartilhadas levando a um maior reaproveitamento do esforÃ§o de desenvolvimento e entregando somente o que cada fragmento precisa como CSS e JS, e 2) Edge Side Includes (ESI) que entrega dinamicamente para cada fragmento o que Ã© necessÃ¡rio quando solicitado.</p>\n<p>Ã‰ comum a separaÃ§Ã£o de responsabilidade por camadas no front-end e, tambÃ©m, no backend, isso porque os atores da aplicaÃ§Ã£o possuem objetivos diferentes, ( NÃ£o confunda isso com estrutura de pastas ) as camadas nesse nÃ­vel representam as partes independentes da aplicaÃ§Ã£o como por exemplo a camada de entrada e infraestrutura cada uma com seu objetivo.</p>\n<p><strong>PadrÃµes arquiteturais amplos</strong></p>\n<p><em>First thing: Design Pattern â‰  Arquitetura</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/981/1*vfxVbZCaVvIhp8H333TEJQ.png\"><figcaption><a href=\"https://leanylabs.com/blog/micro-frontends-overview/\">https://leanylabs.com/blog/micro-frontends-overview/</a></figcaption></figure><p><strong>Arquitetura MonolÃ­tica</strong></p>\n<p>Abordagem mais tradicional onde todos os componentes sÃ£o integrados em uma Ãºnica base de cÃ³digo. Este modelo simplifica o desenvolvimento inicial e o deployment, mas pode levar a problemas de escalabilidade e manutenÃ§Ã£o Ã  medida que a aplicaÃ§Ã£o cresce. ModificaÃ§Ãµes em uma pequena parte do sistema podem exigir a recompilaÃ§Ã£o e redeployment de toda a aplicaÃ§Ã£o.</p>\n<p><strong>Arquitetura Micro front-end</strong></p>\n<p>Aplica os princÃ­pios de microserviÃ§os ao front-end, onde a interface do usuÃ¡rio Ã© dividida em componentes menores e independentes. Cada componente Ã© responsÃ¡vel por uma parte especÃ­fica da interface e pode ser desenvolvido, implantado e atualizado de forma independente. Esta abordagem permite uma maior flexibilidade e escalabilidade no desenvolvimento de interfaces complexas.</p>\n<p>HÃ¡ algumas escolhas estratÃ©gicas de <strong><em>como</em></strong> todas as partes da aplicaÃ§Ã£o irÃ¡ conversar, alÃ©m disso, <strong><em>onde</em></strong> serÃ¡ renderizada (cliente/servidor/isomÃ³rficoâ€Šâ€”â€ŠPodem incluir hidrataÃ§Ã£o parcial e progressiva dando mais poderes a aplicaÃ§Ã£o e nÃ£o sobrecarregando o cliente), <strong><em>quando</em></strong> serÃ¡ integrada (estÃ¡tico/dinÃ¢mico) e <strong><em>o que</em></strong> serÃ¡ integrado.</p>\n<h4><strong>State management</strong></h4>\n<p>Manter uma Ãºnica fonte de verdade Ã© uma das estratÃ©gias da <strong>camada de estado da aplicaÃ§Ã£o</strong>, nÃ£o hÃ¡ alteraÃ§Ãµes diretas na camada <strong>view</strong> e sim dispatchs para um estado central que modifica a fonte, isso assegura que todos os observadores estejam alinhados. Essa camada nÃ£o esta diretamente conectada ao uso de bibliotecas como Redux, Vuex ou NgRx store e sim a uma estratÃ©gia de envio de eventos a um armazenador deÂ estado.</p>\n<h4><strong>Gerenciamento de versÃ£o de dependÃªncias</strong></h4>\n<p>Talvez essa seja a ponta mais subestimada. No planejamento dos ciclos de entrega quantas vezes se fala em separar tempo + esforÃ§o para atualizar o framework/biblioteca usada na construÃ§Ã£o da aplicaÃ§Ã£o? Ou de bibliotecas de suporte? Considere que anualmente novas majors release sÃ£o lanÃ§adas e a versÃ£o que seu software usa muitas vezes sequer recebe suporte pela equipe dona da ferramenta. O custo de refatoraÃ§Ã£o pode ficar bem alto Ã  medida que o tempo passa e nÃ£o hÃ¡ dimensÃ£o do escopo de refatoraÃ§Ã£o. O que fazerÂ ? Primeiramente, <strong>automatizar a verificaÃ§Ã£o de atualizaÃ§Ãµes.</strong> Ferramentas como NPM jÃ¡ fazem isso. ApÃ³s ter isso mapeado, <strong>EstabeleÃ§a uma polÃ­tica</strong> clara para quando e como as dependÃªncias devem ser atualizadas. Isso pode incluir atualizaÃ§Ãµes semestrais ou trimestrais para aquelas cuja atualizaÃ§Ã£o necessita de ajuste de cÃ³digo. <strong>Remova dependÃªncias nÃ£o utilizadas,</strong> muitos projetos carregam esses pesos mortos atÃ© o fim por descuido.</p>\n<p><strong>Use ferramentas de auditoria</strong>. <strong>Quando</strong> e <strong>o que</strong> atualizar? Use <a href=\"https://legacy.reactjs.org/docs/faq-versioning.html\">versionamento semÃ¢ntico</a> (Semantic Versioning) para entender o impacto das atualizaÃ§Ãµes (MAJOR.MINOR.PATCH).</p>\n<h4><strong>Testes</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*PJY8KEDjlmnIQR2qw9UrZg.png\"><figcaption><a href=\"https://www.netguru.com/blog/front-end-testing\">https://www.netguru.com/blog/front-end-testing</a></figcaption></figure><p>NÃ£o hÃ¡ um ROI explicito em escrever testes no desenvolvimento de software do ponto de vista do negÃ³cio, Ã© algo extremamente tÃ©cnico, entretanto os usuÃ¡rios sofrem com pÃ©ssimas experiÃªncias em aplicaÃ§Ãµes sem fluxo de testes porque isso aumenta a incidÃªncia deÂ bugs.</p>\n<p>Se nÃ£o considerarmos TDD ou outras prÃ¡ticas que priorizam testes e pensarmos em uma base de cÃ³digo jÃ¡ evoluÃ­da, <strong>o que testar</strong> Ã© uma boa questÃ£o. Assim como qual percentual de coverage considerar.</p>\n<p><em>Importante priorizar cobertura nas Ã¡reas que mais impactam a experiÃªncia do usuÃ¡rio e a estabilidade da aplicaÃ§Ã£o, como componentes principais da UI, lÃ³gica de gerenciamento de estado e integraÃ§Ã£o comÂ APIs.</em></p>\n<p><strong>O queÂ ?</strong></p>\n<ol><li><strong>Camada de ApresentaÃ§Ã£o (UI/UX)</strong></li></ol>\n<p><strong>Componentes de Interface</strong>:</p>\n<ul><li>\n<strong>Testes UnitÃ¡rios</strong>: Verificar a renderizaÃ§Ã£o correta de componentes individuais, props, estados eÂ eventos.</li></ul>\n<p><strong>Fluxos deÂ UsuÃ¡rio</strong>:</p>\n<ul>\n<li>\n<strong>Testes de IntegraÃ§Ã£o</strong>: Garantir que os componentes funcionem corretamente em conjunto e que a navegaÃ§Ã£o entre as telas esteja conforme o esperado.</li>\n<li>\n<strong>Testes End-to-End (E2E)</strong>: Simular a interaÃ§Ã£o do usuÃ¡rio com a aplicaÃ§Ã£o, desde o inÃ­cio atÃ© o fim de um fluxo importante.</li>\n</ul>\n<p><strong>2. Camada de LÃ³gica de AplicaÃ§Ã£o</strong></p>\n<p><strong>Gerenciamento deÂ Estado</strong>:</p>\n<ul>\n<li>\n<strong>Testes UnitÃ¡rios</strong>: Verificar a lÃ³gica de atualizaÃ§Ã£o doÂ estado.</li>\n<li>\n<strong>Testes de IntegraÃ§Ã£o</strong>: Assegurar que o estado global da aplicaÃ§Ã£o seja atualizado corretamente e que os componentes reagem de maneira esperada Ã s mudanÃ§as deÂ estado.</li>\n</ul>\n<p><strong>3. Camada de ComunicaÃ§Ã£o com Servidores (API)</strong></p>\n<p><strong>Chamadas deÂ API</strong>:</p>\n<ul>\n<li>\n<strong>Testes UnitÃ¡rios</strong>: Mockar chamadas de API para verificar que as funÃ§Ãµes fazem requests corretos e lidam adequadamente com as respostas.</li>\n<li>\n<strong>Testes de IntegraÃ§Ã£o</strong>: Assegurar que a aplicaÃ§Ã£o interaja corretamente com as APIs, lidando bem com diferentes tipos de respostas (sucesso, erro,Â etc).</li>\n</ul>\n<p><strong>4. Camada de SeguranÃ§a</strong></p>\n<p><strong>AutenticaÃ§Ã£o e AutorizaÃ§Ã£o</strong>:</p>\n<ul>\n<li>\n<strong>Testes UnitÃ¡rios</strong>: Verificar que os componentes e funÃ§Ãµes responsÃ¡veis pela autenticaÃ§Ã£o e autorizaÃ§Ã£o se comportem conforme esperado.</li>\n<li>\n<strong>Testes de IntegraÃ§Ã£o</strong>: Assegurar que apenas usuÃ¡rios autenticados possam acessar certas partes da aplicaÃ§Ã£o e que as permissÃµes sejam corretamente aplicadas.</li>\n</ul>\n<p><strong>Cobertura de Testes (Coverage)</strong></p>\n<p><strong>Percentual de Coverage</strong>:</p>\n<ul><li>\n<strong>Meta Realista</strong>: Um percentual de cobertura entre 60% e 90% Ã© geralmente considerado saudÃ¡vel. Cobertura de 100% nÃ£o Ã© necessÃ¡ria e pode ser impraticÃ¡vel, mas Ã© crucial garantir que as partes crÃ­ticas da aplicaÃ§Ã£o sejam bem cobertas.</li></ul>\n<h3>Reach out toÂ me</h3>\n<p>Espero ter esboÃ§ado meu interesse no tema de forma que contribua no seu processo. Esse nÃ£o Ã© um fim, esse tema Ã© grande e complexo. Muitos artigos e estudo ainda estÃ£o surgindo nessa Ã¡rea. Com a evoluÃ§Ã£o da tecnologia e a necessidade de mensurar pontas que eram meramente empÃ­ricas estÃ£o se tornando indispensÃ¡veis.</p>\n<p>AtÃ© o prÃ³ximoÂ :)</p>\n<p>Meu LinkedIn: <a href=\"https://www.linkedin.com/in/leticiamirelly/\">https://www.linkedin.com/in/leticiamirelly/</a></p>\n<h4>ReferÃªncias:</h4>\n<p><em>Ruby Midwest 2011â€Šâ€”â€ŠKeynote: Architecture the Lost Years by Robert Martinâ€Šâ€”â€Š</em><a href=\"https://www.youtube.com/watch?v=WpkDN78P884\"><em>https://www.youtube.com/watch?v=WpkDN78P884</em></a></p>\n<p><em>The cost of JavaScript in 2019â€Šâ€”â€ŠAddy Osmani </em><a href=\"https://v8.dev/blog/cost-of-javascript-2019\"><em>https://v8.dev/blog/cost-of-javascript-2019</em></a></p>\n<p><em>Code Red: The Business Impact of Code Qualityâ€Šâ€”â€ŠA Quantitative Study of 39 Proprietary Production Codebasesâ€Šâ€”â€Š</em><a href=\"https://arxiv.org/pdf/2203.04374\"><em>https://arxiv.org/pdf/2203.04374</em></a></p>\n<p><em>Increasing, not Diminishing: Investigating the Returns of Highly Maintainable Codeâ€Šâ€”â€Š</em><a href=\"https://arxiv.org/html/2401.13407v1\">https://arxiv.org/html/2401.13407v1</a></p>\n<p><em>Principles of Developer Experience </em><a href=\"https://cpojer.net/posts/principles-of-devx#5-maximize-option-value\"><em>https://cpojer.net/posts/principles-of-devx#5-maximize-option-value</em></a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1c9d63242d21\" width=\"1\" height=\"1\" alt=\"\">\n",
			"content": "\n<h3>Construa uma vez, escale por anosâ€Šâ€”â€ŠAplicaÃ§Ãµes front-end que nascem paraÂ durar.</h3>\n<a href=\"https://medium.com/media/e6590a4ef3722310fdbf785bde4228c5/href\">https://medium.com/media/e6590a4ef3722310fdbf785bde4228c5/href</a><p>Muitas decisÃµes de negÃ³cios ainda priorizam a velocidade de entrega em detrimento da qualidade do desenvolvimento de software, resultando em consequÃªncias desastrosas. Dentre os exemplos mais recentes, em 2022, <a href=\"https://www.nytimes.com/2022/12/31/opinion/southwest-airlines-computers.html\">o sistema de agendamento de tripulaÃ§Ãµes da Southwest Airlines</a> nÃ£o conseguiu lidar com interrupÃ§Ãµes inesperadas no clima de inverno, levando a muitos cancelamentos de voos e perdas financeiras de aproximadamente 410 milhÃµes de dÃ³lares. Outro exemplo Ã© o dos voos Lion Air 610 e Ethiopian Airlines 302, ambos envolvendo aeronaves <a href=\"https://www.rollingstone.com/culture/culture-features/boeing-737-max-disasters-timeline-1235007089/\">Boeing 737 Max</a>, que tiveram parte do problema atribuÃ­da a falhas no software do sistema de controle de voo (MCAS) e na documentaÃ§Ã£o.</p>\n<h4>As perguntas que tentarei responder sÃ£o: Como evidenciar o impacto comercial e financeiro na performance evolutiva de uma aplicaÃ§Ã£o a medida que ela cresce e quais as pontas gerir para nÃ£o cair no dilema das â€œ<a href=\"https://pt.wikipedia.org/wiki/Teoria_das_janelas_quebradas\">janelas quebradas</a>â€.</h4>\n<p>Esse Ã© um tema pretensioso, eu sei. Como desenvolvedora jÃ¡ trabalhei em alguns projetos legados, projetos com ciclos de vida enormes e fui â€œmÃ£eâ€ de outros, sempre questionei a fundo sobre o que aquela aplicaÃ§Ã£o viria a se tornar a nÃ­vel de escopo, entretanto essa Ã© sempre uma grande variÃ¡vel que custa a ser mensurada. Acredito fazer sentido responder algo pretensioso assim com um punhado de referÃªncias externas e pessoais a fim de documentar estudos e experiÃªncias.</p>\n<p><em>Algumas palavras preferi manter em InglÃªs ao invÃ©s de traduzi-las, acredito ser mais proveitoso e eficaz manter como sÃ£o comumente conhecidas.</em></p>\n<p>Com base no estudo <a href=\"https://arxiv.org/abs/2203.04374\">Code Red: The Business Impact of Code Quality</a>, 39 bases de cÃ³digos de produÃ§Ã£o foram analisados com 30.737 arquivos se baseando na mÃ©trica de Code Health da CodeScene como um proxy para qualidade de cÃ³digo considerando a anÃ¡lise de cÃ³digo-fonte, mineraÃ§Ã£o de controle de versÃ£o e informaÃ§Ãµes de emissÃ£o do Jira foi percebido que cÃ³digo de baixa qualidade contÃ©m 15 vezes mais defeitos do que o cÃ³digo de alta qualidade e cÃ³digos de baixa qualidade leva em mÃ©dia 124% mais tempo de desenvolvimento. O estudo evidencia ainda que atÃ© 42% do tempo dos desenvolvedores Ã© desperdiÃ§ado lidando com dÃ­vidas tÃ©cnicas, custando uma mÃ©dia de US$ 85 bilhÃµes por ano. HÃ¡ uma ponte a ser construÃ­da entre o time que realiza a entrega e o time comercial, com 15x menos defeitos e com mais previsibilidade do tempo de desenvolvimento e entrega, a vantagem competitiva de produzir cÃ³digo de qualidade de forma sustentÃ¡vel a longo prazo e com curto time-to-market torna-seÂ clara.</p>\n<p>Infelizmente essa ainda nÃ£o Ã© uma visÃ£o amplamente abraÃ§ada pela Ã¡rea de negÃ³cio porque muitas vezes nÃ£o hÃ¡ clareza de benefÃ­cios quantificÃ¡veis em pagar por refatoraÃ§Ãµes por isso os gestores nÃ£o concedem o orÃ§amento e prioridade necessÃ¡rias e acabam negociando as entregas levando em conta o curto prazo muitas vezes chegando no viÃ©s da tomada de decisÃ£o <em>desconto hiperbÃ³lico</em>, onde seus eus futuros lidam com as consequÃªncias de escolhas que prefeririam nÃ£o te-lasÂ feito.</p>\n<h3><strong>KPIs da qualidade de software: idiotas da objetividade?</strong></h3>\n<p>Embora existam muitas pesquisas concentradas em nortear a qualidade de software nÃ£o se pode declarar a mesma soluÃ§Ã£o para todas as aplicaÃ§Ãµes, entretanto podemos usar ferramentas e mÃ©todos tangÃ­veis. Essas ferramentas sÃ£o o comeÃ§o, e nÃ£o o fim, de como tangibilizar e negociar dÃ©bitos tÃ©cnicos com os gestores.</p>\n<h4>Gerenciar a DÃ­vidaÂ tÃ©cnica</h4>\n<a href=\"https://medium.com/media/523d0736ba1ed8bea0818da53353b981/href\">https://medium.com/media/523d0736ba1ed8bea0818da53353b981/href</a><p>A teoria teoria das janelas quebradas, emprestada da criminologia e aplicada no contexto do desenvolvimento de software (William LevÃ©n, <a href=\"https://arxiv.org/pdf/2209.01549\">2023</a> ), trata da relaÃ§Ã£o causal entre a quantidade de dÃ©bitos tÃ©cnicos de uma aplicaÃ§Ã£o e a propensÃ£o dos desenvolvedores inserirem novos dÃ©bitos tÃ©cnicos Ã  medida que a aplicaÃ§Ã£o cresce. Avaliando fatores psicolÃ³gicos, o comportamento Ã© moldado por uma norma descritiva, onde o comportamento torna-se ser aceitÃ¡vel. Dentre alguns insights alarmantes estÃ¡ a ligaÃ§Ã£o entre DT e a propensÃ£o Ã  vulnerabilidade da aplicaÃ§Ã£o incluindo riscos de seguranÃ§a.</p>\n<p><strong>Tipos de dÃ­vidaÂ tÃ©cnica:</strong></p>\n<ul>\n<li>\n<strong>Qualidade do cÃ³digo: </strong>Baixa manutenibilidade, padrÃµes de cÃ³digo inexistentes, mal projetado e muito complexo.</li>\n<li><strong>Baixa cobertura de cÃ³digo e de teste automatizado.</strong></li>\n<li><strong>Bibliotecas e/ou ferramentas desatualizadas/legadas.</strong></li>\n<li><strong>Arquitetura errada ou inexistente.</strong></li>\n<li><strong>Falta de documentaÃ§Ã£o.</strong></li>\n<li><strong>Defeitos/Bugs.</strong></li>\n<li><strong>Entre outros como por exemplo processo manual deÂ CI/CD.</strong></li>\n</ul>\n<p>Para gerenciar eficazmente hÃ¡ algumas etapas como: 1) <strong>identificar as dÃ­vidas,</strong> 2) <strong>Torna-las visÃ­veis,</strong> 3) <strong>Implementar mudanÃ§as e mitigar os efeitos daÂ dÃ­vida.</strong></p>\n<h4><strong>Dando nome Ã s dÃ­vidasÂ tÃ©cnicas</strong></h4>\n<p>De forma prÃ¡tica, hÃ¡ algumas ferramentas de analise automÃ¡tica parcial do cÃ³digo como SonarQube que identifica violaÃ§Ãµes de prÃ¡ticas de codificaÃ§Ã£o e calcula o custo de refatoraÃ§Ã£o de cada dÃ­vida. HÃ¡ ainda dÃ­vidas que nÃ£o sÃ£o encontradas por ferramentas de analise automatizada mas sÃ£o conhecidas pelo time de desenvolvimento, Ã© aconselhÃ¡vel mante-las juntamente com dÃ­vidas fornecidas por uma ferramenta em um backlog tÃ©cnico com a descriÃ§Ã£o do que deverÃ¡ ser feito e estimativa para resolver.</p>\n<h4><strong>Mapa de dÃ©bitosÂ tÃ©cnicos</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*QLDIMgUxwMsz6545GWF4Qg.jpeg\"></figure><p>Esse mapa foi tirado do <a href=\"https://blog.thepete.net/blog/2020/12/01/tech-debt-walls/\">artigo publicado por Pete HogsonÂ </a>, onde as dÃ­vidas sÃ£o colocadas em duas dimensÃµes de <strong>custo</strong> e <strong>valor</strong>. Em suas palavras, Os problemas na Ã¡rea inferior esquerda do muro sÃ£o â€œvitÃ³rias rÃ¡pidasâ€â€Šâ€”â€Šo tipo de cortesia que vocÃª pode receber se quiser limpar um pouco o acampamento em uma tarde tranquila de sexta-feira. Problemas na Ã¡rea superior esquerda do muro sÃ£o â€œfÃ¡ceis de resolverâ€â€Šâ€”â€Štrabalho de baixo custo e alto valor que deve ser resolvido em breve. Por outro lado, problemas na Ã¡rea inferior direita do quadro sÃ£o os itens â€œnÃ£oâ€. O investimento simplesmente nÃ£o vale a pena quando se trata desses problemas. O restante do muro contÃ©m â€œinvestimentos valiososâ€â€Šâ€”â€Šitens de dÃ­vida que provavelmente fornecerÃ£o um bom retorno sobre o investimento, mas tambÃ©m sÃ£o substanciais o suficiente para exigir negociaÃ§Ã£o com outras partes interessadas para serem priorizados.</p>\n<h4><strong>O que fazer com essas informaÃ§Ãµes?</strong></h4>\n<p><a href=\"https://www.computer.org/\">Frank Buscgmann cita 3 estratÃ©gias:</a></p>\n<ul>\n<li>\n<strong>Pague a dÃ­vida: </strong>Refatorar ou substituir oÂ cÃ³digo.</li>\n<li>\n<strong>ConversÃ£o de dÃ­vida: </strong>Substitua a soluÃ§Ã£o atual por uma soluÃ§Ã£o â€œboa, mas nÃ£o perfeitaâ€.</li>\n<li>\n<strong>Pague apenas os juros: </strong>Viva com o cÃ³digo, porque a refatoraÃ§Ã£o Ã© mais cara do que trabalhar com o cÃ³digo nÃ£o muitoÂ correto.</li>\n</ul>\n<blockquote>\n<strong><em>A refatoraÃ§Ã£o substancial Ã© sempre uma decisÃ£o de negÃ³cios(Wolff, </em></strong><a href=\"https://www.infoq.com/articles/managing-technical-debt/\"><strong><em>2013</em></strong></a><strong><em>)</em></strong>\n</blockquote>\n<h4>Modelo de criaÃ§Ã£o deÂ valor</h4>\n<p>Uma analise aprofundada sobre o retorno do investimento em esforÃ§os de refatoraÃ§Ã£o Ã© dada no modelo de criaÃ§Ã£o de valor (<a href=\"https://arxiv.org/html/2401.13407v1#abstract\">2024, </a>Markus Borg) e SPACE framework que mensura a <strong>capacidade</strong> e <strong>eficiÃªncia</strong> do time de desenvolvimento. O modelo de criaÃ§Ã£o de valor concentra-se em modelos de regressÃ£o para identificar a relaÃ§Ã£o entre Code Health e duas variÃ¡veis que dependem entre si: 1) nÃºmero mÃ©dio de defeitos e 2) tempo mÃ©dio de Desvio, evidenciando como retorno da analise o impacto de mudanÃ§as relativas na qualidade do cÃ³digo-fonte.</p>\n<p><strong>Capacidade</strong> mÃ¡xima que a organizaÃ§Ã£o pode alcanÃ§ar em condiÃ§Ãµes ideais. Maior capacidade == mais tempo de codificaÃ§Ã£o;</p>\n<p><strong>EficiÃªncia</strong> Ã© a capacidade convertida em valor real. Maior eficiÃªncia menos interrupÃ§Ã£o.</p>\n<p><strong>ğ‘¢</strong> = <strong>fraÃ§Ã£o de trabalho nÃ£o planejado</strong></p>\n<p>EficiÃªncia = (1â€Šâ€”â€Š<strong>ğ‘¢</strong>)</p>\n<blockquote>v = c Ã— ( 1 âˆ’ ğ‘¢Â )</blockquote>\n<p>Considera-se tambÃ©m duas proporcionalidades: A primeira Ã© que <em>a capacidade Ã© inversamente proporcional ao Time-in-Dev.</em></p>\n<blockquote>Quanto mais os desenvolvedores trabalham na implementaÃ§Ã£o de uma resoluÃ§Ã£o, mais recursos sÃ£o amarrados para lidar com ela. Esses recursos poderiam, em vez disso, ter sido alocados para o desenvolvimento de novos recursos que contribuem diretamente para a capacidade de desenvolvimento.</blockquote>\n<p>E em segundo lugar,<em> </em><strong><em>a fraÃ§Ã£o de trabalho nÃ£o planejado Ã© proporcional ao nÃºmero de defeitos.</em></strong></p>\n<p>Embora tenha se verificado uma nÃ£o linearidade total entre Code Health e criaÃ§Ã£o de valor os resultados da pesquisa sugeremÂ que:</p>\n<ul>\n<li>As funÃ§Ãµes tÃ©cnicas devem comunicar melhor os benefÃ­cios aos nÃ­veis executivos para informar as decisÃµes estratÃ©gicas de refatoraÃ§Ã£o.</li>\n<li>Evitar diligentemente cheiros de cÃ³digo em arquivos onde a taxa de juros sobre a dÃ­vida tÃ©cnica Ã© alta, ou seja, arquivos com rotatividade substancial.</li>\n<li>Os desenvolvedores resolvem problemas rapidamenteâ€Šâ€”â€Še possivelmente de forma imprudenteâ€Šâ€”â€Šse a qualidade do cÃ³digo jÃ¡ forÂ pÃ©ssima.</li>\n</ul>\n<h3>Mais afundoâ€Šâ€”â€ŠAmarrando asÂ pontas</h3>\n<p><em>NÃ£o pretendo aprofundar na escolha da stack, poderia escrever um artigo somente sobre isso se for desejÃ¡vel, me deixe saber nos comentÃ¡rios.</em></p>\n<blockquote>if youâ€™re afraid to change something it is clearly poorly designed.<br>â€Šâ€”â€ŠMartinÂ Fowler</blockquote>\n<h4>High-level architecture</h4>\n<p>Arquitetura Ã© a forma como as unidades da aplicaÃ§Ã£o interagem entre si, aqui a preocupaÃ§Ã£o Ã© mais a nÃ­vel estrutural do que a detalhes de implementaÃ§Ã£o e/ou tecnologias de suporte. A arquitetura Ã© guiada pelo domÃ­nio e casos deÂ uso.</p>\n<p>Resolver questÃµes complexas na construÃ§Ã£o de aplicaÃ§Ãµes front-end tem se tornado mais simples mas nÃ£o mais fÃ¡cil, isso porque as arquiteturas mudaram muito nos Ãºltimos 30 anos Ã  medida que o clÃ¡ssico Model View Control (MVC) evoluÃ­a para dar entrada Ã  novas estruturas mais modernas. Curioso perceber que mesmo as estruturas mais atuais foram construÃ­das em estruturas jÃ¡ existentes adicionando melhorias continuas.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*tao7a30JsPeaYv01ijFhTg.png\"><figcaption>Imagem do livro front-end reactive architectures</figcaption></figure><p><em>De antemÃ£o, nÃ£o hÃ¡ razÃµes determinÃ­sticas que orientem a arquitetura por um viÃ©s padrÃ£o Ã  todas, nenhuma arquitetura Ã© boa em si mesmo, o mesmo serve para a escolha da stack, a mais â€œhypadaâ€ nÃ£o deveria ser escolhida por este motivo tambÃ©m, a escolha se baseia na necessidade do produto e doÂ negÃ³cio.</em></p>\n<p>Na prÃ¡tica, representar os requisitos do software sÃ£o de maior peso na balanÃ§a, eles podem mudar todo o cenÃ¡rio, um exemplo clÃ¡ssico Ã© a <a href=\"https://gustafnk.github.io/microservice-websites/\">IKEA</a> que devido ao contexto do produto decidiram implementar 2 tÃ©cnicas: 1) Fragmentos autocontidos (SCS) em uma arquitetura micro front-end que atende a demandas de equipes diferentes com funcionalidades compartilhadas levando a um maior reaproveitamento do esforÃ§o de desenvolvimento e entregando somente o que cada fragmento precisa como CSS e JS, e 2) Edge Side Includes (ESI) que entrega dinamicamente para cada fragmento o que Ã© necessÃ¡rio quando solicitado.</p>\n<p>Ã‰ comum a separaÃ§Ã£o de responsabilidade por camadas no front-end e, tambÃ©m, no backend, isso porque os atores da aplicaÃ§Ã£o possuem objetivos diferentes, ( NÃ£o confunda isso com estrutura de pastas ) as camadas nesse nÃ­vel representam as partes independentes da aplicaÃ§Ã£o como por exemplo a camada de entrada e infraestrutura cada uma com seu objetivo.</p>\n<p><strong>PadrÃµes arquiteturais amplos</strong></p>\n<p><em>First thing: Design Pattern â‰  Arquitetura</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/981/1*vfxVbZCaVvIhp8H333TEJQ.png\"><figcaption><a href=\"https://leanylabs.com/blog/micro-frontends-overview/\">https://leanylabs.com/blog/micro-frontends-overview/</a></figcaption></figure><p><strong>Arquitetura MonolÃ­tica</strong></p>\n<p>Abordagem mais tradicional onde todos os componentes sÃ£o integrados em uma Ãºnica base de cÃ³digo. Este modelo simplifica o desenvolvimento inicial e o deployment, mas pode levar a problemas de escalabilidade e manutenÃ§Ã£o Ã  medida que a aplicaÃ§Ã£o cresce. ModificaÃ§Ãµes em uma pequena parte do sistema podem exigir a recompilaÃ§Ã£o e redeployment de toda a aplicaÃ§Ã£o.</p>\n<p><strong>Arquitetura Micro front-end</strong></p>\n<p>Aplica os princÃ­pios de microserviÃ§os ao front-end, onde a interface do usuÃ¡rio Ã© dividida em componentes menores e independentes. Cada componente Ã© responsÃ¡vel por uma parte especÃ­fica da interface e pode ser desenvolvido, implantado e atualizado de forma independente. Esta abordagem permite uma maior flexibilidade e escalabilidade no desenvolvimento de interfaces complexas.</p>\n<p>HÃ¡ algumas escolhas estratÃ©gicas de <strong><em>como</em></strong> todas as partes da aplicaÃ§Ã£o irÃ¡ conversar, alÃ©m disso, <strong><em>onde</em></strong> serÃ¡ renderizada (cliente/servidor/isomÃ³rficoâ€Šâ€”â€ŠPodem incluir hidrataÃ§Ã£o parcial e progressiva dando mais poderes a aplicaÃ§Ã£o e nÃ£o sobrecarregando o cliente), <strong><em>quando</em></strong> serÃ¡ integrada (estÃ¡tico/dinÃ¢mico) e <strong><em>o que</em></strong> serÃ¡ integrado.</p>\n<h4><strong>State management</strong></h4>\n<p>Manter uma Ãºnica fonte de verdade Ã© uma das estratÃ©gias da <strong>camada de estado da aplicaÃ§Ã£o</strong>, nÃ£o hÃ¡ alteraÃ§Ãµes diretas na camada <strong>view</strong> e sim dispatchs para um estado central que modifica a fonte, isso assegura que todos os observadores estejam alinhados. Essa camada nÃ£o esta diretamente conectada ao uso de bibliotecas como Redux, Vuex ou NgRx store e sim a uma estratÃ©gia de envio de eventos a um armazenador deÂ estado.</p>\n<h4><strong>Gerenciamento de versÃ£o de dependÃªncias</strong></h4>\n<p>Talvez essa seja a ponta mais subestimada. No planejamento dos ciclos de entrega quantas vezes se fala em separar tempo + esforÃ§o para atualizar o framework/biblioteca usada na construÃ§Ã£o da aplicaÃ§Ã£o? Ou de bibliotecas de suporte? Considere que anualmente novas majors release sÃ£o lanÃ§adas e a versÃ£o que seu software usa muitas vezes sequer recebe suporte pela equipe dona da ferramenta. O custo de refatoraÃ§Ã£o pode ficar bem alto Ã  medida que o tempo passa e nÃ£o hÃ¡ dimensÃ£o do escopo de refatoraÃ§Ã£o. O que fazerÂ ? Primeiramente, <strong>automatizar a verificaÃ§Ã£o de atualizaÃ§Ãµes.</strong> Ferramentas como NPM jÃ¡ fazem isso. ApÃ³s ter isso mapeado, <strong>EstabeleÃ§a uma polÃ­tica</strong> clara para quando e como as dependÃªncias devem ser atualizadas. Isso pode incluir atualizaÃ§Ãµes semestrais ou trimestrais para aquelas cuja atualizaÃ§Ã£o necessita de ajuste de cÃ³digo. <strong>Remova dependÃªncias nÃ£o utilizadas,</strong> muitos projetos carregam esses pesos mortos atÃ© o fim por descuido.</p>\n<p><strong>Use ferramentas de auditoria</strong>. <strong>Quando</strong> e <strong>o que</strong> atualizar? Use <a href=\"https://legacy.reactjs.org/docs/faq-versioning.html\">versionamento semÃ¢ntico</a> (Semantic Versioning) para entender o impacto das atualizaÃ§Ãµes (MAJOR.MINOR.PATCH).</p>\n<h4><strong>Testes</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*PJY8KEDjlmnIQR2qw9UrZg.png\"><figcaption><a href=\"https://www.netguru.com/blog/front-end-testing\">https://www.netguru.com/blog/front-end-testing</a></figcaption></figure><p>NÃ£o hÃ¡ um ROI explicito em escrever testes no desenvolvimento de software do ponto de vista do negÃ³cio, Ã© algo extremamente tÃ©cnico, entretanto os usuÃ¡rios sofrem com pÃ©ssimas experiÃªncias em aplicaÃ§Ãµes sem fluxo de testes porque isso aumenta a incidÃªncia deÂ bugs.</p>\n<p>Se nÃ£o considerarmos TDD ou outras prÃ¡ticas que priorizam testes e pensarmos em uma base de cÃ³digo jÃ¡ evoluÃ­da, <strong>o que testar</strong> Ã© uma boa questÃ£o. Assim como qual percentual de coverage considerar.</p>\n<p><em>Importante priorizar cobertura nas Ã¡reas que mais impactam a experiÃªncia do usuÃ¡rio e a estabilidade da aplicaÃ§Ã£o, como componentes principais da UI, lÃ³gica de gerenciamento de estado e integraÃ§Ã£o comÂ APIs.</em></p>\n<p><strong>O queÂ ?</strong></p>\n<ol><li><strong>Camada de ApresentaÃ§Ã£o (UI/UX)</strong></li></ol>\n<p><strong>Componentes de Interface</strong>:</p>\n<ul><li>\n<strong>Testes UnitÃ¡rios</strong>: Verificar a renderizaÃ§Ã£o correta de componentes individuais, props, estados eÂ eventos.</li></ul>\n<p><strong>Fluxos deÂ UsuÃ¡rio</strong>:</p>\n<ul>\n<li>\n<strong>Testes de IntegraÃ§Ã£o</strong>: Garantir que os componentes funcionem corretamente em conjunto e que a navegaÃ§Ã£o entre as telas esteja conforme o esperado.</li>\n<li>\n<strong>Testes End-to-End (E2E)</strong>: Simular a interaÃ§Ã£o do usuÃ¡rio com a aplicaÃ§Ã£o, desde o inÃ­cio atÃ© o fim de um fluxo importante.</li>\n</ul>\n<p><strong>2. Camada de LÃ³gica de AplicaÃ§Ã£o</strong></p>\n<p><strong>Gerenciamento deÂ Estado</strong>:</p>\n<ul>\n<li>\n<strong>Testes UnitÃ¡rios</strong>: Verificar a lÃ³gica de atualizaÃ§Ã£o doÂ estado.</li>\n<li>\n<strong>Testes de IntegraÃ§Ã£o</strong>: Assegurar que o estado global da aplicaÃ§Ã£o seja atualizado corretamente e que os componentes reagem de maneira esperada Ã s mudanÃ§as deÂ estado.</li>\n</ul>\n<p><strong>3. Camada de ComunicaÃ§Ã£o com Servidores (API)</strong></p>\n<p><strong>Chamadas deÂ API</strong>:</p>\n<ul>\n<li>\n<strong>Testes UnitÃ¡rios</strong>: Mockar chamadas de API para verificar que as funÃ§Ãµes fazem requests corretos e lidam adequadamente com as respostas.</li>\n<li>\n<strong>Testes de IntegraÃ§Ã£o</strong>: Assegurar que a aplicaÃ§Ã£o interaja corretamente com as APIs, lidando bem com diferentes tipos de respostas (sucesso, erro,Â etc).</li>\n</ul>\n<p><strong>4. Camada de SeguranÃ§a</strong></p>\n<p><strong>AutenticaÃ§Ã£o e AutorizaÃ§Ã£o</strong>:</p>\n<ul>\n<li>\n<strong>Testes UnitÃ¡rios</strong>: Verificar que os componentes e funÃ§Ãµes responsÃ¡veis pela autenticaÃ§Ã£o e autorizaÃ§Ã£o se comportem conforme esperado.</li>\n<li>\n<strong>Testes de IntegraÃ§Ã£o</strong>: Assegurar que apenas usuÃ¡rios autenticados possam acessar certas partes da aplicaÃ§Ã£o e que as permissÃµes sejam corretamente aplicadas.</li>\n</ul>\n<p><strong>Cobertura de Testes (Coverage)</strong></p>\n<p><strong>Percentual de Coverage</strong>:</p>\n<ul><li>\n<strong>Meta Realista</strong>: Um percentual de cobertura entre 60% e 90% Ã© geralmente considerado saudÃ¡vel. Cobertura de 100% nÃ£o Ã© necessÃ¡ria e pode ser impraticÃ¡vel, mas Ã© crucial garantir que as partes crÃ­ticas da aplicaÃ§Ã£o sejam bem cobertas.</li></ul>\n<h3>Reach out toÂ me</h3>\n<p>Espero ter esboÃ§ado meu interesse no tema de forma que contribua no seu processo. Esse nÃ£o Ã© um fim, esse tema Ã© grande e complexo. Muitos artigos e estudo ainda estÃ£o surgindo nessa Ã¡rea. Com a evoluÃ§Ã£o da tecnologia e a necessidade de mensurar pontas que eram meramente empÃ­ricas estÃ£o se tornando indispensÃ¡veis.</p>\n<p>AtÃ© o prÃ³ximoÂ :)</p>\n<p>Meu LinkedIn: <a href=\"https://www.linkedin.com/in/leticiamirelly/\">https://www.linkedin.com/in/leticiamirelly/</a></p>\n<h4>ReferÃªncias:</h4>\n<p><em>Ruby Midwest 2011â€Šâ€”â€ŠKeynote: Architecture the Lost Years by Robert Martinâ€Šâ€”â€Š</em><a href=\"https://www.youtube.com/watch?v=WpkDN78P884\"><em>https://www.youtube.com/watch?v=WpkDN78P884</em></a></p>\n<p><em>The cost of JavaScript in 2019â€Šâ€”â€ŠAddy Osmani </em><a href=\"https://v8.dev/blog/cost-of-javascript-2019\"><em>https://v8.dev/blog/cost-of-javascript-2019</em></a></p>\n<p><em>Code Red: The Business Impact of Code Qualityâ€Šâ€”â€ŠA Quantitative Study of 39 Proprietary Production Codebasesâ€Šâ€”â€Š</em><a href=\"https://arxiv.org/pdf/2203.04374\"><em>https://arxiv.org/pdf/2203.04374</em></a></p>\n<p><em>Increasing, not Diminishing: Investigating the Returns of Highly Maintainable Codeâ€Šâ€”â€Š</em><a href=\"https://arxiv.org/html/2401.13407v1\">https://arxiv.org/html/2401.13407v1</a></p>\n<p><em>Principles of Developer Experience </em><a href=\"https://cpojer.net/posts/principles-of-devx#5-maximize-option-value\"><em>https://cpojer.net/posts/principles-of-devx#5-maximize-option-value</em></a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1c9d63242d21\" width=\"1\" height=\"1\" alt=\"\">\n",
			"enclosure": {},
			"categories": [
				"arquitetura",
				"desenvolvimento",
				"front-end-development"
			]
		},
		{
			"title": "Enhancing Front-End Decision-Making: Navigating the Choice Between Nuxt.js and Vue.js",
			"pubDate": "2024-01-12 04:06:01",
			"link": "https://leticia-mirelly.medium.com/enhancing-front-end-decision-making-navigating-the-choice-between-nuxt-js-and-vue-js-26ff459f0f74?source=rss-7deace8b3a8e------2",
			"guid": "https://medium.com/p/26ff459f0f74",
			"author": "Leticia Mirelly ÏŸ",
			"thumbnail": "",
			"description": "\n<a href=\"https://medium.com/media/7b629623f8be94d54e2cc499aff3ed44/href\">https://medium.com/media/7b629623f8be94d54e2cc499aff3ed44/href</a><blockquote>Let me give you a small introduction before IÂ begin</blockquote>\n<h3><strong>Brief Introduction toÂ Vue.js</strong></h3>\n<p>Vue.js was originally created by Evan You in 2014 and has since garnered significant contributions from the community. It emerged in the market as a lightweight and intuitive alternative to the dominant frontend frameworks such as Angular and React. Its value proposition lies in combining an easy learning curve with powerful reactivity and flexibility. The Vue.js 3 team includes seasoned engineers, many of whom have contributed to other popular frameworks and libraries, bringing a diversity of experiences to the project. The source code and repository of Vue.js 2 are maintained in a central repository. While the Vue.js 2 source code is well-structured, the monolithic nature of the repository can pose challenges in managing new features and experiments. On the other hand, Vue.js 3 adopted a modular approach and used a monorepo for code management, which has facilitated maintenance, testing, and the addition of new features.</p>\n<h4>Component-Oriented Architecture</h4>\n<p>Component-Oriented Architecture Vue.js extends HTML with a template syntax that allows for the declarative expression of DOM rendering based on the state of the applicationâ€™s data. To render the user interface, Vue.js uses a Virtual DOMâ€Šâ€”â€Ša lightweight representation of the real DOM. This enables Vue.js to calculate the minimal changes needed to update the UI without re-rendering the entire DOM tree. Vue.js implements a highly optimized â€œdiffâ€ algorithm that compares the Virtual DOM with a previous version to detect the exact differences. This results in a minimum number of DOM manipulations. The declarative templates are compiled into JavaScript rendering functions. These functions return Virtual DOM trees whenever the component data changes, which is excellent for performance.</p>\n<h4>Reactivity</h4>\n<p>There are two ways to intercept property access in JavaScript: getters/setters and Proxies. Vue 2 exclusively used getters/setters due to browser support limitations. In Vue 3, Proxies are used for reactive objects, and getters/setters are used for refs.Reactivity based on Proxies reduces the initialization overhead of components. In Vue.js 2, the need to recursively convert all properties of an object into getters/setters increased the startup time, particularly for large datasets.Projects in Vue.js 2 typically rely on tools like Webpack and Vue Loader to processÂ .vue files and generate bundles. This approach can depend on specific configurations and plugins to work correctly. Vue.js 3 is developed and maintained as a monorepo, which includes sub-packages like @vue/runtime-dom and @vue/reactivity. This allows projects to import only the parts of Vue they need, reducing the size of the final bundle. With Vue.js 3, there is a growing movement towards the use of more modern and efficient build tools like Vite, which leverages ES modules for faster development.</p>\n<h4>Some comparisons with other frameworks</h4>\n<p>Vue.js offers a declarative approach to building UIs that is more straightforward and less verbose than Angular. Compared to Reactâ€™s JSX, Vueâ€™s templates are closer to HTML, making them more accessible to beginners and developers with strong HTML/CSS experience.</p>\n<p>Vue.js introduced the concept of Single-File Components (SFCs), which encapsulate a componentâ€™s template, logic, and styles in a single file. This approach simplifies code organization and enhances clarity compared to the separate methods of managing template and logic in frameworks like Angular. The Vue ecosystem includes official solutions for routing (Vue Router) and state management (Vuex) that are designed to work seamlessly with Vue core. React and Angular also have strong ecosystems, but Vue benefits from tighter integration and a less complex state management model compared to Redux inÂ React.</p>\n<h4>\n<em>For new projects, itâ€™s highly recommended to use the latest version of Vue.js, which, at the moment, is </em><a href=\"https://blog.vuejs.org/posts/vue-3-one-piece\"><em>Vue.js 3</em></a><em>. This version brings significant improvements in terms of performance, enhanced reactivity through the Proxy-based system, the Composition API for better code organization, along with other advanced features.</em>\n</h4>\n<h4><em>If migrating to Vue.js 3 is not feasible at the moment, maintaining the latest minor or patch version of Vue.js 2 is advisable, especially to ensure security and compatibility with current libraries.</em></h4>\n<p><em>If you missed it, Vue.js 2 became obsolete along with the packages on npm since December 31,Â 2023:</em></p>\n<ul>\n<li><em>All major and minor versions of Vue 2Â core</em></li>\n<li><em>Versions of vue-router with exclusive support for Vue 2 (3.x andÂ below)</em></li>\n<li><em>Vuex versions with exclusive support for Vue 2 (3.x andÂ below)</em></li>\n</ul>\n<p><em>More details can be found at: </em><a href=\"https://blog.vuejs.org/posts/vue-2-eol\"><em>https://blog.vuejs.org/posts/vue-2-eol</em></a></p>\n<h4>Boilerplates for Creating Vue.jsÂ Projects</h4>\n<p><strong><em>Vite</em></strong> is a next-generation build tool that significantly improves the development experience. It uses Rollup for production builds and features an extremely fast development server based on native ES modules. It is ideal for projects seeking speed in the development and build process. Its rapid hot-module reloading (HMR) and simplified configuration make it suitable for modern SPAs and Vue.js projects that demand high-performance.</p>\n<p><strong><em>Vue CLI</em></strong> is the standard tool for creating Vue.js projects. It offers a rich set of configuration options, plugins, and a GUI for project management. It is well-suited for developers who prefer a more traditional and comprehensive setup for their Vue.js applications.</p>\n<p><strong><em>Quasar</em></strong> is a Vue.js framework that enables developers to build SPA, SSR, PWA, Mobile (using Cordova or Capacitor), and Electron applications with a single codebase. It is best for projects that require multiple platform/rendering solutions with a unified codebase, providing versatility and efficiency in development.</p>\n<p>In addition to these, there are other notable templates and frameworks in the Vue.js ecosystem, each offering unique features and benefits to cater to different needs and preferences in web and application development.</p>\n<h3><strong>Brief Introduction toÂ Nuxt.js</strong></h3>\n<p>Nuxt.js was created by French brothers SÃ©bastien and Alexandre Chopin, with its first version released in 2016. The goal was to create a framework that simplified the development process with Vue.js, focusing particularly on server-side rendering (SSR) and automatic configuration.</p>\n<p>Nuxt.js is particularly valued for its ability to improve SEO (Search Engine Optimization) and the initial page loading performance, which are common challenges in Single Page Applications (SPAs). It simplifies the implementation of SSR by automating much of the process. This includes setting up the server, rendering Vue.js components, and managing synchronization between server and client. It also offers the capability to generate a static site. This means that all application pages are pre-rendered during the build process, generating static HTMLÂ files.</p>\n<p>From the outset, Nuxt.js was developed to complement and enhance Vue.jsâ€™s capabilities. For example, automatic routing is one of Nuxt.jsâ€™s most attractive features, eliminating the need to manually define application routes using Vue Router. During the build process, Nuxt.js automatically generates the Vue Router configuration based on the structure of the â€˜pagesâ€™ directory.</p>\n<p>Nuxt.js utilizes a specific directory structure that includes pages, components, layouts, plugins, middleware, assets, and static. This structure is an integral part of Nuxt.jsâ€™s convention-over-configuration approach. Plugins are frequently used to add global libraries (like Axios for HTTP requests or Vuetify as a UI library) or to inject global functions and constants.</p>\n<h4>Applications with Strong SEOÂ Needs</h4>\n<p>For applications that rely on good visibility in search engines, like blogs and e-commerce sites, server-side rendering (SSR) is essential. SSR ensures that the content is fully rendered on the server side, making it more easily indexable by search engines, which is crucial forÂ SEO.</p>\n<h4>High-Performance Websites</h4>\n<p>For websites where loading performance is crucial, such as portfolios or corporate pages, static site generation offers the best solution. Static sites are faster to load and more efficient in terms of server resource usage because the HTML is pre-rendered and ready to be served instantly.</p>\n<p>Nuxt.js uses Webpack as its module bundler. During the build process, Webpack processes and packages resources such as JavaScript, Vue components, CSS, and images. This bundling is vital for optimizing application performance, as it reduces the number of requests needed to load a webpage and can include optimizations like minification and treeÂ shaking.</p>\n<h4>Dependency Management and Versioning</h4>\n<p>Nuxt.js also adopts SemVer, and each version of Nuxt is typically built to work with a specific version of Vue.js. For instance, Nuxt.js v2 is compatible with Vue.js v2.x, while Nuxt.js v3 is designed to work with Vue.js v3. This ensures that when a developer chooses a specific version of Nuxt.js, they can be confident about which version of Vue.js it is compatible with, which is crucial for maintaining consistency and stability in application development.</p>\n<h4>Evolution of Nuxt.js: From Early to CurrentÂ Versions</h4>\n<p><a href=\"https://medium.com/@nuxt_js/nuxt-js-1-0-is-out-bab1af459972\"><strong><em>Nuxt.js 1.x</em></strong></a><strong> </strong>The early versions of Nuxt.js focused on providing a framework for Vue.js applications with server-side rendering (SSR) out-of-the-box. This approach simplified the development of SSR and SPA (Single Page Application) applications, making it easier for developers to create complex, SEO-friendly web applications without dealing with the intricacies of server-side rendering configurations.</p>\n<p><a href=\"https://medium.com/@nuxt_js/nuxt-js-2-0-webpack-4-esm-modules-create-nuxt-app-and-more-6936ce80d94c\"><strong><em>Nuxt.js 2.x</em></strong></a><strong><em> </em></strong>Updates in this series brought significant improvements, such as Static Site Generation (SSG) and automatic optimization for performance. There were also advances in modularity and extensibility, with the introduction of Nuxt.js modules that could add functionality to the framework without the need for extensive manual configuration. This version made Nuxt.js more flexible and powerful, catering to a wider range of web development needs.</p>\n<p><a href=\"https://nuxt.com/docs/getting-started/installation\"><strong><em>Transition to Vue.js 3</em></strong></a> The introduction of Vue.js 3, with features like the Composition API, Proxy-based reactivity, and enhanced TypeScript support, necessitated corresponding adaptations in Nuxt.js. This led to the development and eventual release of Nuxt.js 3, which was a significant step in keeping the framework aligned with the latest Vue.js features and improvements.</p>\n<p><strong><em>Nuxt.js 3 and Beyond</em></strong><em> </em>Nuxt.js 3 was designed to leverage all the new functionalities of Vue.js 3. It offers a rewrite of the core to use the Composition API, improves support for TypeScript, and incorporates performance enhancements from the new version of Vue.js. This version represents a major leap forward in terms of developer experience, performance, and capabilities, making it a robust choice for modern web development.</p>\n<h3>Detailed Comparison</h3>\n<p>When comparing Vue.js and Nuxt.js, itâ€™s crucial to understand that they are not direct competitors but complementary to each other. Vue.js is a progressive framework for building user interfaces, while Nuxt.js is a framework based on Vue.js, designed to simplify the development of universal (SSR) and single-page applications (SPAs).</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/631/1*rKtYy2yw9tjc6IgWLGyAmA.png\"></figure><h4>Main Use</h4>\n<ul><li>\n<strong>Vue.js</strong> is ideal for building dynamic user interfaces. <strong>Nuxt.js</strong>, being a layer on top of Vue.js, is more suitable for projects that require server-side rendering or static site generation.</li></ul>\n<h4>Routing</h4>\n<ul><li>\n<strong>Vue.js</strong> offers flexibility in routing but requires manual configuration. <strong>Nuxt.js</strong> automates this process, making routing easier based on the directory structure.</li></ul>\n<h4>SEO and Performance</h4>\n<ul><li>\n<strong>SPAs in Vue.js</strong> may face challenges with SEO due to their client-side nature. <strong>Nuxt.js</strong> addresses these issues with SSR and SSG, offering better SEO practices and faster initial loadingÂ times.</li></ul>\n<h4>Project Structure</h4>\n<ul><li>While <strong>Vue.js allows for a more flexible approach to project structuring</strong>, <strong>Nuxt.js offers a more standardized project structure</strong>, which can speed up development, especially in larger projects.</li></ul>\n<p>When evaluating Vue.js and Nuxt.js from the perspectives of <strong>scalability</strong>, <strong>maintainability</strong>, and <strong>performance</strong>, we are considering how these technologies behave as applications grow in complexity and size, and how they facilitate ongoing maintenance.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/519/1*Wa2ri_btTNzQAUmgUpiEOg.png\"></figure><h3>Nuxt.js Case Study: Large-Scale E-Commerce</h3>\n<h4>Platform Developing a robust e-commerce platform, with thousands of products, high user customization, and strict SEO and performance demands.</h4>\n<p><strong><em>Server-Side Rendering (SSR) for SEO and Performance:</em></strong> Traditional SPAs face challenges with SEO and initial load time.<strong><em> Solution:</em></strong> With native SSR, Nuxt.js significantly improves SEO and page loading speed, which is crucial for an e-commerce site.</p>\n<p><strong><em>Static Site Generation (SSG) for Product Pages:</em></strong> Maintaining performance with a large number of product pages. <strong><em>Solution:</em></strong> Using SSG, Nuxt.js can generate static pages for each product, reducing server load and improving loading speed. Project Structure and Automatic Routing.</p>\n<p><strong><em>Managing a large codebase and complex routing. Solution:</em></strong> Nuxt.jsâ€™s project structure and automatic routing simplify code organization and route management, increasing development efficiency.</p>\n<p><strong><em>Modularity and Plugins:</em> </strong>Integrating various features such as payment systems, inventory management, and user customization. <strong>Solution:</strong> The modular architecture of Nuxt.js and support for plugins allow for clean and maintainable integration of complex functionalities. Internationalization and Localization</p>\n<p><strong><em>Adapting the platform for multiple languages and regions. Solution:</em></strong> With the nuxt-i18n module, the platform can easily support multiple languages, facilitating content localization.</p>\n<h4><strong>Results andÂ Benefits</strong></h4>\n<p><strong><em>Improved User Experience: </em></strong>The application loads quickly, even with a large amount of dynamic content, thanks to SSR andÂ SSG.</p>\n<p><strong><em>Simplified Maintenance:</em> </strong>Maintenance is easier due to the organized structure and the ease of updates and integrations.</p>\n<p><strong><em>Assured Scalability:</em></strong> The site is able to handle an increase in traffic and product quantity without sacrificing performance.</p>\n<h3>Vue.js Case Study: Analytics Dashboard Platform</h3>\n<h4><strong>Create an interactive analytics dashboard for a medium-sized company, providing real-time insights into sales data, customer engagement, and product performance.</strong></h4>\n<p><strong><em>Rapid and Iterative Development. Solution:</em></strong> With Vue CLI, the project can be quickly bootstrapped, and Vue.jsâ€™s declarative syntax and reusable components allow for fast iterative development.</p>\n<p><strong><em>Performance and Optimization:</em></strong> Ensuring smooth performance with large volumes of data. <strong><em>Solution</em></strong>: Vue.js offers an efficient reactive system and Virtual DOM to optimize UI updates, maintaining performance even with large dataÂ volumes.</p>\n<p><strong><em>Scalability and Maintenance:</em> </strong>The application must be easy to scale and maintain.<strong><em> Solution: </em></strong>The modular and component-based architecture of Vue.js, along with an active community and excellent documentation, facilitate scalability and maintenance.</p>\n<h4>Results andÂ Benefits</h4>\n<p><strong><em>Development Agility:</em></strong> The prototype was developed and iterated quickly, thanks to the ease of use ofÂ Vue.js.</p>\n<p><strong><em>Optimized Performance: </em></strong>The dashboard maintained high performance, even when handling and displaying data in real-time.</p>\n<h3>Guidelines for Efficient Code Architecture</h3>\n<h4>Modularity and Encapsulation</h4>\n<p><strong><em>Component-Oriented Design: </em></strong>Divide the application into smaller, independent components. This not only facilitates reuse and maintenance but also allows for more efficient testing.</p>\n<p><strong><em>Component Encapsulation:</em></strong> Use encapsulation to hide the internal complexity of components, exposing only clear and well-defined interfaces.</p>\n<h4>Clean and Separated Architecture</h4>\n<p><strong><em>Model-View-ViewModel (MVVM) Pattern: </em></strong>Separate business logic (Model), presentation layer (View), and presentation logic (ViewModel). This promotes efficient decoupling and facilitates unitÂ testing.</p>\n<p><strong><em>Service Layer:</em></strong> Introduce a service layer to abstract business logic and interactions with external APIs or theÂ backend.</p>\n<h4>State Management Patterns</h4>\n<p>State management patterns are crucial in frontend applications, especially as complexity and size increase. These patterns provide an organized framework for managing and maintaining application state predictably and efficiently.</p>\n<p><strong><em>Vuex </em></strong>is a state management pattern and library for Vue.js applications. It serves as a centralized store for all components in an application. Features: Deep integration with Vueâ€™s reactivity system. Concepts of state, getters, actions, and mutations. Facilitates the maintenance and management of shared states in large Vue applications.</p>\n<p><strong><em>Pinia</em></strong> is the latest addition to the Vue.js ecosystem as an alternative to Vuex for state management. Developed with Vue 3â€™s Composition API in mind, Pinia offers a more intuitive and flexible state management experience. <strong><em>Stores as State Sources</em> </strong>In Pinia, each â€œstoreâ€ is essentially a source of reactive state. Stores are lighter and more flexible compared to Vuex stores. <strong><em>Hot Module Replacement (HMR),</em></strong> meaning store state can be preserved during hot-reloading during development. Easy to Learn and Use Piniaâ€™s framework and API are simpler and more straightforward, making it easier to learn and use, especially for new Vue developers.</p>\n<h4>Routing and LazyÂ Loading</h4>\n<p>Implement dynamic routing and permission-based routing to manage access to different areas of the application.</p>\n<h4>Advanced CSS Practices</h4>\n<p>Adopt methodologies like BEM, SMACSS, or OOCSS to maintain scalable and maintainable styles.</p>\n<h4>Automated Testing</h4>\n<p>Implement unit tests, integration tests, and end-to-end (E2E) tests to ensure codeÂ quality.</p>\n<h4>Linting and Code Formatting</h4>\n<p>Use tools like ESLint and Prettier to maintain code consistency and identify potential issues earlyÂ on.</p>\n<blockquote>An efficient code architecture in frontend projects requires a holistic approach that encompasses everything from component structure to advanced state management practices and performance optimization. These guidelines are essential for creating scalable, efficient, and easy-to-maintain applications, suitable for the complex needs of web development.</blockquote>\n<h3>Tips for optimizing code performance and maintenance: Strategies to keep code clean and performant</h3>\n<h4>Clean Code Principles</h4>\n<p><strong><em>Readability:</em> </strong>Write code as if it were a book. This includes descriptive variable and function names, as well as a clear logical structure.</p>\n<p><strong><em>Simplicity: </em></strong>Avoid unnecessary complexity. Simpler solutions are often easier to maintain.</p>\n<p><strong><em>DRY (Donâ€™t Repeat Yourself): </em></strong>Eliminate code repetition. Reuse code whenever possible to reduce duplication and ease futureÂ changes.</p>\n<p><strong><em>Efficient State Management (</em></strong><em>Local vs. Global State): </em>Carefully assess the need for global state. Use local state whenever possible to reduce complexity.</p>\n<p><strong><em>Caching and Memoization: </em></strong>Implement caching and memoization for heavy operations, such as API queries or complex calculations.</p>\n<h3>Conclusion</h3>\n<h4>Features and Practices</h4>\n<p><strong>Vue.jsâ€Šâ€”â€ŠFlexibility and Intuitiveness: </strong>Vue.js is ideal for SPAs and dynamic user interfaces, known for its smooth learning curve, componentization, and efficient reactivity.</p>\n<p><strong>Nuxt.jsâ€Šâ€”â€ŠStructure and Optimization: </strong>Nuxt.js extends Vue.js capabilities, offering standardized structures and additional features like SSR and SSG, ideal for projects requiring enhanced SEO and performance.</p>\n<p><strong>Design Patterns and Code Architecture: </strong>Adopting clear design patterns and efficient code architecture, such as modularity, encapsulation, and state management, is crucial for scalability and maintainability.</p>\n<h3><strong>Choosing between Vue.js and Nuxt.js for a specific project depends on various factors related to the projectâ€™s needs and objectives. Here are some final guidelines to help make this decision:</strong></h3>\n<h4>Considering the Scope and Project Requirements</h4>\n<p><strong>Vue.js: </strong>Ideal for projects that require a flexible and customizable approach, such as Single Page Applications (SPAs) or when integrating Vue into an existingÂ project.</p>\n<p><strong>Nuxt.js:</strong> Better suited for projects that benefit from Server-Side Rendering (SSR) or Static Site Generation (SSG), such as applications that need improved SEO and better initial loading performance.</p>\n<h4>Evaluating Team Experience and Available Resources</h4>\n<p><strong>Learning Curve: </strong>Teams already familiar with Vue.js will find it easy to adopt Nuxt.js, but for those who are new to both, Vue.js can be a more accessible starting point due to its smoother learningÂ curve.</p>\n<p><strong>Resources and Community:</strong> Both have active communities and a good number of available resources. Considering community support and resources can be crucial, especially for smaller teams or projects with limitedÂ budgets.</p>\n<h4>SEO and Performance</h4>\n<p>If SEO and initial loading performance are priorities, Nuxt.js with its integrated SSR and SSG is the most suitableÂ choice.</p>\n<h4>Flexibility vs. Convention</h4>\n<p><strong>Vue.js: </strong>Offers greater flexibility in structuring the project. <strong>Nuxt.js:</strong> Provides directory structure conventions that can speed up development and ensure consistency, especially useful in larger teams or projects with many developers.</p>\n<p><em>The choice between Vue.js and Nuxt.js should be based on a careful assessment of the projectâ€™s specific needs, available resources, and the development teamâ€™s experience. Vue.js is better suited for projects that require a flexible and customizable approach, while Nuxt.js is ideal for projects that need advanced features like SSR and SSG for SEO and performance. Evaluating these factors will help ensure that the chosen technology aligns with the projectâ€™s goals and requirements, maximizing development efficiency andÂ success.</em></p>\n<blockquote>Feel free to <a href=\"https://www.linkedin.com/in/leticiamirelly/\">connect with me on LinkedIn</a> for any further discussions or questions you may have. HappyÂ coding!</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=26ff459f0f74\" width=\"1\" height=\"1\" alt=\"\">\n",
			"content": "\n<a href=\"https://medium.com/media/7b629623f8be94d54e2cc499aff3ed44/href\">https://medium.com/media/7b629623f8be94d54e2cc499aff3ed44/href</a><blockquote>Let me give you a small introduction before IÂ begin</blockquote>\n<h3><strong>Brief Introduction toÂ Vue.js</strong></h3>\n<p>Vue.js was originally created by Evan You in 2014 and has since garnered significant contributions from the community. It emerged in the market as a lightweight and intuitive alternative to the dominant frontend frameworks such as Angular and React. Its value proposition lies in combining an easy learning curve with powerful reactivity and flexibility. The Vue.js 3 team includes seasoned engineers, many of whom have contributed to other popular frameworks and libraries, bringing a diversity of experiences to the project. The source code and repository of Vue.js 2 are maintained in a central repository. While the Vue.js 2 source code is well-structured, the monolithic nature of the repository can pose challenges in managing new features and experiments. On the other hand, Vue.js 3 adopted a modular approach and used a monorepo for code management, which has facilitated maintenance, testing, and the addition of new features.</p>\n<h4>Component-Oriented Architecture</h4>\n<p>Component-Oriented Architecture Vue.js extends HTML with a template syntax that allows for the declarative expression of DOM rendering based on the state of the applicationâ€™s data. To render the user interface, Vue.js uses a Virtual DOMâ€Šâ€”â€Ša lightweight representation of the real DOM. This enables Vue.js to calculate the minimal changes needed to update the UI without re-rendering the entire DOM tree. Vue.js implements a highly optimized â€œdiffâ€ algorithm that compares the Virtual DOM with a previous version to detect the exact differences. This results in a minimum number of DOM manipulations. The declarative templates are compiled into JavaScript rendering functions. These functions return Virtual DOM trees whenever the component data changes, which is excellent for performance.</p>\n<h4>Reactivity</h4>\n<p>There are two ways to intercept property access in JavaScript: getters/setters and Proxies. Vue 2 exclusively used getters/setters due to browser support limitations. In Vue 3, Proxies are used for reactive objects, and getters/setters are used for refs.Reactivity based on Proxies reduces the initialization overhead of components. In Vue.js 2, the need to recursively convert all properties of an object into getters/setters increased the startup time, particularly for large datasets.Projects in Vue.js 2 typically rely on tools like Webpack and Vue Loader to processÂ .vue files and generate bundles. This approach can depend on specific configurations and plugins to work correctly. Vue.js 3 is developed and maintained as a monorepo, which includes sub-packages like @vue/runtime-dom and @vue/reactivity. This allows projects to import only the parts of Vue they need, reducing the size of the final bundle. With Vue.js 3, there is a growing movement towards the use of more modern and efficient build tools like Vite, which leverages ES modules for faster development.</p>\n<h4>Some comparisons with other frameworks</h4>\n<p>Vue.js offers a declarative approach to building UIs that is more straightforward and less verbose than Angular. Compared to Reactâ€™s JSX, Vueâ€™s templates are closer to HTML, making them more accessible to beginners and developers with strong HTML/CSS experience.</p>\n<p>Vue.js introduced the concept of Single-File Components (SFCs), which encapsulate a componentâ€™s template, logic, and styles in a single file. This approach simplifies code organization and enhances clarity compared to the separate methods of managing template and logic in frameworks like Angular. The Vue ecosystem includes official solutions for routing (Vue Router) and state management (Vuex) that are designed to work seamlessly with Vue core. React and Angular also have strong ecosystems, but Vue benefits from tighter integration and a less complex state management model compared to Redux inÂ React.</p>\n<h4>\n<em>For new projects, itâ€™s highly recommended to use the latest version of Vue.js, which, at the moment, is </em><a href=\"https://blog.vuejs.org/posts/vue-3-one-piece\"><em>Vue.js 3</em></a><em>. This version brings significant improvements in terms of performance, enhanced reactivity through the Proxy-based system, the Composition API for better code organization, along with other advanced features.</em>\n</h4>\n<h4><em>If migrating to Vue.js 3 is not feasible at the moment, maintaining the latest minor or patch version of Vue.js 2 is advisable, especially to ensure security and compatibility with current libraries.</em></h4>\n<p><em>If you missed it, Vue.js 2 became obsolete along with the packages on npm since December 31,Â 2023:</em></p>\n<ul>\n<li><em>All major and minor versions of Vue 2Â core</em></li>\n<li><em>Versions of vue-router with exclusive support for Vue 2 (3.x andÂ below)</em></li>\n<li><em>Vuex versions with exclusive support for Vue 2 (3.x andÂ below)</em></li>\n</ul>\n<p><em>More details can be found at: </em><a href=\"https://blog.vuejs.org/posts/vue-2-eol\"><em>https://blog.vuejs.org/posts/vue-2-eol</em></a></p>\n<h4>Boilerplates for Creating Vue.jsÂ Projects</h4>\n<p><strong><em>Vite</em></strong> is a next-generation build tool that significantly improves the development experience. It uses Rollup for production builds and features an extremely fast development server based on native ES modules. It is ideal for projects seeking speed in the development and build process. Its rapid hot-module reloading (HMR) and simplified configuration make it suitable for modern SPAs and Vue.js projects that demand high-performance.</p>\n<p><strong><em>Vue CLI</em></strong> is the standard tool for creating Vue.js projects. It offers a rich set of configuration options, plugins, and a GUI for project management. It is well-suited for developers who prefer a more traditional and comprehensive setup for their Vue.js applications.</p>\n<p><strong><em>Quasar</em></strong> is a Vue.js framework that enables developers to build SPA, SSR, PWA, Mobile (using Cordova or Capacitor), and Electron applications with a single codebase. It is best for projects that require multiple platform/rendering solutions with a unified codebase, providing versatility and efficiency in development.</p>\n<p>In addition to these, there are other notable templates and frameworks in the Vue.js ecosystem, each offering unique features and benefits to cater to different needs and preferences in web and application development.</p>\n<h3><strong>Brief Introduction toÂ Nuxt.js</strong></h3>\n<p>Nuxt.js was created by French brothers SÃ©bastien and Alexandre Chopin, with its first version released in 2016. The goal was to create a framework that simplified the development process with Vue.js, focusing particularly on server-side rendering (SSR) and automatic configuration.</p>\n<p>Nuxt.js is particularly valued for its ability to improve SEO (Search Engine Optimization) and the initial page loading performance, which are common challenges in Single Page Applications (SPAs). It simplifies the implementation of SSR by automating much of the process. This includes setting up the server, rendering Vue.js components, and managing synchronization between server and client. It also offers the capability to generate a static site. This means that all application pages are pre-rendered during the build process, generating static HTMLÂ files.</p>\n<p>From the outset, Nuxt.js was developed to complement and enhance Vue.jsâ€™s capabilities. For example, automatic routing is one of Nuxt.jsâ€™s most attractive features, eliminating the need to manually define application routes using Vue Router. During the build process, Nuxt.js automatically generates the Vue Router configuration based on the structure of the â€˜pagesâ€™ directory.</p>\n<p>Nuxt.js utilizes a specific directory structure that includes pages, components, layouts, plugins, middleware, assets, and static. This structure is an integral part of Nuxt.jsâ€™s convention-over-configuration approach. Plugins are frequently used to add global libraries (like Axios for HTTP requests or Vuetify as a UI library) or to inject global functions and constants.</p>\n<h4>Applications with Strong SEOÂ Needs</h4>\n<p>For applications that rely on good visibility in search engines, like blogs and e-commerce sites, server-side rendering (SSR) is essential. SSR ensures that the content is fully rendered on the server side, making it more easily indexable by search engines, which is crucial forÂ SEO.</p>\n<h4>High-Performance Websites</h4>\n<p>For websites where loading performance is crucial, such as portfolios or corporate pages, static site generation offers the best solution. Static sites are faster to load and more efficient in terms of server resource usage because the HTML is pre-rendered and ready to be served instantly.</p>\n<p>Nuxt.js uses Webpack as its module bundler. During the build process, Webpack processes and packages resources such as JavaScript, Vue components, CSS, and images. This bundling is vital for optimizing application performance, as it reduces the number of requests needed to load a webpage and can include optimizations like minification and treeÂ shaking.</p>\n<h4>Dependency Management and Versioning</h4>\n<p>Nuxt.js also adopts SemVer, and each version of Nuxt is typically built to work with a specific version of Vue.js. For instance, Nuxt.js v2 is compatible with Vue.js v2.x, while Nuxt.js v3 is designed to work with Vue.js v3. This ensures that when a developer chooses a specific version of Nuxt.js, they can be confident about which version of Vue.js it is compatible with, which is crucial for maintaining consistency and stability in application development.</p>\n<h4>Evolution of Nuxt.js: From Early to CurrentÂ Versions</h4>\n<p><a href=\"https://medium.com/@nuxt_js/nuxt-js-1-0-is-out-bab1af459972\"><strong><em>Nuxt.js 1.x</em></strong></a><strong> </strong>The early versions of Nuxt.js focused on providing a framework for Vue.js applications with server-side rendering (SSR) out-of-the-box. This approach simplified the development of SSR and SPA (Single Page Application) applications, making it easier for developers to create complex, SEO-friendly web applications without dealing with the intricacies of server-side rendering configurations.</p>\n<p><a href=\"https://medium.com/@nuxt_js/nuxt-js-2-0-webpack-4-esm-modules-create-nuxt-app-and-more-6936ce80d94c\"><strong><em>Nuxt.js 2.x</em></strong></a><strong><em> </em></strong>Updates in this series brought significant improvements, such as Static Site Generation (SSG) and automatic optimization for performance. There were also advances in modularity and extensibility, with the introduction of Nuxt.js modules that could add functionality to the framework without the need for extensive manual configuration. This version made Nuxt.js more flexible and powerful, catering to a wider range of web development needs.</p>\n<p><a href=\"https://nuxt.com/docs/getting-started/installation\"><strong><em>Transition to Vue.js 3</em></strong></a> The introduction of Vue.js 3, with features like the Composition API, Proxy-based reactivity, and enhanced TypeScript support, necessitated corresponding adaptations in Nuxt.js. This led to the development and eventual release of Nuxt.js 3, which was a significant step in keeping the framework aligned with the latest Vue.js features and improvements.</p>\n<p><strong><em>Nuxt.js 3 and Beyond</em></strong><em> </em>Nuxt.js 3 was designed to leverage all the new functionalities of Vue.js 3. It offers a rewrite of the core to use the Composition API, improves support for TypeScript, and incorporates performance enhancements from the new version of Vue.js. This version represents a major leap forward in terms of developer experience, performance, and capabilities, making it a robust choice for modern web development.</p>\n<h3>Detailed Comparison</h3>\n<p>When comparing Vue.js and Nuxt.js, itâ€™s crucial to understand that they are not direct competitors but complementary to each other. Vue.js is a progressive framework for building user interfaces, while Nuxt.js is a framework based on Vue.js, designed to simplify the development of universal (SSR) and single-page applications (SPAs).</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/631/1*rKtYy2yw9tjc6IgWLGyAmA.png\"></figure><h4>Main Use</h4>\n<ul><li>\n<strong>Vue.js</strong> is ideal for building dynamic user interfaces. <strong>Nuxt.js</strong>, being a layer on top of Vue.js, is more suitable for projects that require server-side rendering or static site generation.</li></ul>\n<h4>Routing</h4>\n<ul><li>\n<strong>Vue.js</strong> offers flexibility in routing but requires manual configuration. <strong>Nuxt.js</strong> automates this process, making routing easier based on the directory structure.</li></ul>\n<h4>SEO and Performance</h4>\n<ul><li>\n<strong>SPAs in Vue.js</strong> may face challenges with SEO due to their client-side nature. <strong>Nuxt.js</strong> addresses these issues with SSR and SSG, offering better SEO practices and faster initial loadingÂ times.</li></ul>\n<h4>Project Structure</h4>\n<ul><li>While <strong>Vue.js allows for a more flexible approach to project structuring</strong>, <strong>Nuxt.js offers a more standardized project structure</strong>, which can speed up development, especially in larger projects.</li></ul>\n<p>When evaluating Vue.js and Nuxt.js from the perspectives of <strong>scalability</strong>, <strong>maintainability</strong>, and <strong>performance</strong>, we are considering how these technologies behave as applications grow in complexity and size, and how they facilitate ongoing maintenance.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/519/1*Wa2ri_btTNzQAUmgUpiEOg.png\"></figure><h3>Nuxt.js Case Study: Large-Scale E-Commerce</h3>\n<h4>Platform Developing a robust e-commerce platform, with thousands of products, high user customization, and strict SEO and performance demands.</h4>\n<p><strong><em>Server-Side Rendering (SSR) for SEO and Performance:</em></strong> Traditional SPAs face challenges with SEO and initial load time.<strong><em> Solution:</em></strong> With native SSR, Nuxt.js significantly improves SEO and page loading speed, which is crucial for an e-commerce site.</p>\n<p><strong><em>Static Site Generation (SSG) for Product Pages:</em></strong> Maintaining performance with a large number of product pages. <strong><em>Solution:</em></strong> Using SSG, Nuxt.js can generate static pages for each product, reducing server load and improving loading speed. Project Structure and Automatic Routing.</p>\n<p><strong><em>Managing a large codebase and complex routing. Solution:</em></strong> Nuxt.jsâ€™s project structure and automatic routing simplify code organization and route management, increasing development efficiency.</p>\n<p><strong><em>Modularity and Plugins:</em> </strong>Integrating various features such as payment systems, inventory management, and user customization. <strong>Solution:</strong> The modular architecture of Nuxt.js and support for plugins allow for clean and maintainable integration of complex functionalities. Internationalization and Localization</p>\n<p><strong><em>Adapting the platform for multiple languages and regions. Solution:</em></strong> With the nuxt-i18n module, the platform can easily support multiple languages, facilitating content localization.</p>\n<h4><strong>Results andÂ Benefits</strong></h4>\n<p><strong><em>Improved User Experience: </em></strong>The application loads quickly, even with a large amount of dynamic content, thanks to SSR andÂ SSG.</p>\n<p><strong><em>Simplified Maintenance:</em> </strong>Maintenance is easier due to the organized structure and the ease of updates and integrations.</p>\n<p><strong><em>Assured Scalability:</em></strong> The site is able to handle an increase in traffic and product quantity without sacrificing performance.</p>\n<h3>Vue.js Case Study: Analytics Dashboard Platform</h3>\n<h4><strong>Create an interactive analytics dashboard for a medium-sized company, providing real-time insights into sales data, customer engagement, and product performance.</strong></h4>\n<p><strong><em>Rapid and Iterative Development. Solution:</em></strong> With Vue CLI, the project can be quickly bootstrapped, and Vue.jsâ€™s declarative syntax and reusable components allow for fast iterative development.</p>\n<p><strong><em>Performance and Optimization:</em></strong> Ensuring smooth performance with large volumes of data. <strong><em>Solution</em></strong>: Vue.js offers an efficient reactive system and Virtual DOM to optimize UI updates, maintaining performance even with large dataÂ volumes.</p>\n<p><strong><em>Scalability and Maintenance:</em> </strong>The application must be easy to scale and maintain.<strong><em> Solution: </em></strong>The modular and component-based architecture of Vue.js, along with an active community and excellent documentation, facilitate scalability and maintenance.</p>\n<h4>Results andÂ Benefits</h4>\n<p><strong><em>Development Agility:</em></strong> The prototype was developed and iterated quickly, thanks to the ease of use ofÂ Vue.js.</p>\n<p><strong><em>Optimized Performance: </em></strong>The dashboard maintained high performance, even when handling and displaying data in real-time.</p>\n<h3>Guidelines for Efficient Code Architecture</h3>\n<h4>Modularity and Encapsulation</h4>\n<p><strong><em>Component-Oriented Design: </em></strong>Divide the application into smaller, independent components. This not only facilitates reuse and maintenance but also allows for more efficient testing.</p>\n<p><strong><em>Component Encapsulation:</em></strong> Use encapsulation to hide the internal complexity of components, exposing only clear and well-defined interfaces.</p>\n<h4>Clean and Separated Architecture</h4>\n<p><strong><em>Model-View-ViewModel (MVVM) Pattern: </em></strong>Separate business logic (Model), presentation layer (View), and presentation logic (ViewModel). This promotes efficient decoupling and facilitates unitÂ testing.</p>\n<p><strong><em>Service Layer:</em></strong> Introduce a service layer to abstract business logic and interactions with external APIs or theÂ backend.</p>\n<h4>State Management Patterns</h4>\n<p>State management patterns are crucial in frontend applications, especially as complexity and size increase. These patterns provide an organized framework for managing and maintaining application state predictably and efficiently.</p>\n<p><strong><em>Vuex </em></strong>is a state management pattern and library for Vue.js applications. It serves as a centralized store for all components in an application. Features: Deep integration with Vueâ€™s reactivity system. Concepts of state, getters, actions, and mutations. Facilitates the maintenance and management of shared states in large Vue applications.</p>\n<p><strong><em>Pinia</em></strong> is the latest addition to the Vue.js ecosystem as an alternative to Vuex for state management. Developed with Vue 3â€™s Composition API in mind, Pinia offers a more intuitive and flexible state management experience. <strong><em>Stores as State Sources</em> </strong>In Pinia, each â€œstoreâ€ is essentially a source of reactive state. Stores are lighter and more flexible compared to Vuex stores. <strong><em>Hot Module Replacement (HMR),</em></strong> meaning store state can be preserved during hot-reloading during development. Easy to Learn and Use Piniaâ€™s framework and API are simpler and more straightforward, making it easier to learn and use, especially for new Vue developers.</p>\n<h4>Routing and LazyÂ Loading</h4>\n<p>Implement dynamic routing and permission-based routing to manage access to different areas of the application.</p>\n<h4>Advanced CSS Practices</h4>\n<p>Adopt methodologies like BEM, SMACSS, or OOCSS to maintain scalable and maintainable styles.</p>\n<h4>Automated Testing</h4>\n<p>Implement unit tests, integration tests, and end-to-end (E2E) tests to ensure codeÂ quality.</p>\n<h4>Linting and Code Formatting</h4>\n<p>Use tools like ESLint and Prettier to maintain code consistency and identify potential issues earlyÂ on.</p>\n<blockquote>An efficient code architecture in frontend projects requires a holistic approach that encompasses everything from component structure to advanced state management practices and performance optimization. These guidelines are essential for creating scalable, efficient, and easy-to-maintain applications, suitable for the complex needs of web development.</blockquote>\n<h3>Tips for optimizing code performance and maintenance: Strategies to keep code clean and performant</h3>\n<h4>Clean Code Principles</h4>\n<p><strong><em>Readability:</em> </strong>Write code as if it were a book. This includes descriptive variable and function names, as well as a clear logical structure.</p>\n<p><strong><em>Simplicity: </em></strong>Avoid unnecessary complexity. Simpler solutions are often easier to maintain.</p>\n<p><strong><em>DRY (Donâ€™t Repeat Yourself): </em></strong>Eliminate code repetition. Reuse code whenever possible to reduce duplication and ease futureÂ changes.</p>\n<p><strong><em>Efficient State Management (</em></strong><em>Local vs. Global State): </em>Carefully assess the need for global state. Use local state whenever possible to reduce complexity.</p>\n<p><strong><em>Caching and Memoization: </em></strong>Implement caching and memoization for heavy operations, such as API queries or complex calculations.</p>\n<h3>Conclusion</h3>\n<h4>Features and Practices</h4>\n<p><strong>Vue.jsâ€Šâ€”â€ŠFlexibility and Intuitiveness: </strong>Vue.js is ideal for SPAs and dynamic user interfaces, known for its smooth learning curve, componentization, and efficient reactivity.</p>\n<p><strong>Nuxt.jsâ€Šâ€”â€ŠStructure and Optimization: </strong>Nuxt.js extends Vue.js capabilities, offering standardized structures and additional features like SSR and SSG, ideal for projects requiring enhanced SEO and performance.</p>\n<p><strong>Design Patterns and Code Architecture: </strong>Adopting clear design patterns and efficient code architecture, such as modularity, encapsulation, and state management, is crucial for scalability and maintainability.</p>\n<h3><strong>Choosing between Vue.js and Nuxt.js for a specific project depends on various factors related to the projectâ€™s needs and objectives. Here are some final guidelines to help make this decision:</strong></h3>\n<h4>Considering the Scope and Project Requirements</h4>\n<p><strong>Vue.js: </strong>Ideal for projects that require a flexible and customizable approach, such as Single Page Applications (SPAs) or when integrating Vue into an existingÂ project.</p>\n<p><strong>Nuxt.js:</strong> Better suited for projects that benefit from Server-Side Rendering (SSR) or Static Site Generation (SSG), such as applications that need improved SEO and better initial loading performance.</p>\n<h4>Evaluating Team Experience and Available Resources</h4>\n<p><strong>Learning Curve: </strong>Teams already familiar with Vue.js will find it easy to adopt Nuxt.js, but for those who are new to both, Vue.js can be a more accessible starting point due to its smoother learningÂ curve.</p>\n<p><strong>Resources and Community:</strong> Both have active communities and a good number of available resources. Considering community support and resources can be crucial, especially for smaller teams or projects with limitedÂ budgets.</p>\n<h4>SEO and Performance</h4>\n<p>If SEO and initial loading performance are priorities, Nuxt.js with its integrated SSR and SSG is the most suitableÂ choice.</p>\n<h4>Flexibility vs. Convention</h4>\n<p><strong>Vue.js: </strong>Offers greater flexibility in structuring the project. <strong>Nuxt.js:</strong> Provides directory structure conventions that can speed up development and ensure consistency, especially useful in larger teams or projects with many developers.</p>\n<p><em>The choice between Vue.js and Nuxt.js should be based on a careful assessment of the projectâ€™s specific needs, available resources, and the development teamâ€™s experience. Vue.js is better suited for projects that require a flexible and customizable approach, while Nuxt.js is ideal for projects that need advanced features like SSR and SSG for SEO and performance. Evaluating these factors will help ensure that the chosen technology aligns with the projectâ€™s goals and requirements, maximizing development efficiency andÂ success.</em></p>\n<blockquote>Feel free to <a href=\"https://www.linkedin.com/in/leticiamirelly/\">connect with me on LinkedIn</a> for any further discussions or questions you may have. HappyÂ coding!</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=26ff459f0f74\" width=\"1\" height=\"1\" alt=\"\">\n",
			"enclosure": {},
			"categories": [
				"nuxtjs",
				"clean-code",
				"vuejs",
				"vue",
				"front-end-development"
			]
		},
		{
			"title": "A Comprehensive Guide to npm Workspaces and Monorepos",
			"pubDate": "2023-12-30 14:42:30",
			"link": "https://leticia-mirelly.medium.com/a-comprehensive-guide-to-npm-workspaces-and-monorepos-ce0cdfe1c625?source=rss-7deace8b3a8e------2",
			"guid": "https://medium.com/p/ce0cdfe1c625",
			"author": "Leticia Mirelly ÏŸ",
			"thumbnail": "",
			"description": "\n<h3>A little about current workspace managers</h3>\n<a href=\"https://medium.com/media/86b9287d3e6c7c18976c8b8921174338/href\">https://medium.com/media/86b9287d3e6c7c18976c8b8921174338/href</a><h4>Yarn Classic x Yarn Berry Workspaces</h4>\n<p><strong>Dependency Resolution:</strong> Yarn classic workspaces use a â€œpluggableâ€ resolution algorithm, providing more flexibility in how dependencies are resolved. Like npm, Yarn uses hoisting to share common dependencies at the root level, unlike Yarn Berry, which has a new architecture with a â€œplugâ€™nâ€™playâ€ resolution strategy, aiming for a zero-installation approach. It takes advantage of the concept of â€œPnPâ€ files to represent dependencies without the need for a traditional node_modules directory. This is a complex choice if you want to migrate managers later because Yarn Berry eliminates the need for a central node_modules leading to faster and more efficient installations however brings significant changes in how dependencies are resolved.</p>\n<h4><strong>Npm Workspaces</strong></h4>\n<p><strong>Dependency Resolution: </strong>npm workspaces utilize a â€œfixedâ€ strategy for dependency resolution. Each workspace has its own node_modules, and dependencies are installed per workspace. However, common dependencies are hoisted to the root node_modules to optimize diskÂ space.</p>\n<p><strong>Established Ecosystem Integration:</strong> Being the default package manager for Node.js, npm seamlessly integrates with the broader Node.js ecosystem.</p>\n<p><strong>Share Dependencies: </strong>npm Workspaces enable the sharing of dependencies between packages. If multiple packages require the same dependency, it can be installed once at the workspace level, optimizing disk space and simplifying dependency management.</p>\n<h3>Hands-on with npm workspace</h3>\n<h4>Setup Project</h4>\n<pre>mkdir your-project &amp;&amp; cd your-project &amp;&amp; npm init -y</pre>\n<h4>Parent Workspace Configuration (root package.json)</h4>\n<pre>{<br>  \"name\": \"my-monorepo\",<br>  \"workspaces\": [<br>    \"packages/*\"<br>  ],<br>// Example of shared scripts in workspaces<br>{<br>  \"scripts\": {<br>    \"build\": \"npm run build:package-a &amp;&amp; npm run build:package-b\",<br>    \"build:package-a\": \"cd packages/package-a &amp;&amp; npm run build\",<br>    \"build:package-b\": \"cd packages/package-b &amp;&amp; npm run build\"<br>  }<br>}<br>}</pre>\n<h4>Directory Structure</h4>\n<pre>/my-monorepo<br>|-- /packages<br>|   |-- /package-a<br>|   |-- /package-b<br>|-- package.json</pre>\n<h4>Package A</h4>\n<pre>// /packages/package-a/package.json<br>{<br>  \"name\": \"package-a\",<br>  \"version\": \"1.0.0\",<br>  \"main\": \"index.js\",<br>  \"scripts\": {<br>    \"test\": \"echo \\\"Error: run tests from root\\\" &amp;&amp; exit 1\"<br>  }<br>}</pre>\n<pre>// /packages/package-a/index.js<br>module.exports = () =&gt; {<br>  console.log('Hello from Package A!');<br>};</pre>\n<h4>Package B</h4>\n<pre>// /packages/package-b/package.json<br>{<br>  \"name\": \"package-b\",<br>  \"version\": \"1.0.0\",<br>  \"main\": \"index.js\",<br>  \"dependencies\": {<br>    \"package-a\": \"1.0.0\"<br>  },<br>  \"scripts\": {<br>    \"test\": \"echo \\\"Error: run tests from root\\\" &amp;&amp; exit 1\"<br>  }<br>}</pre>\n<pre>// /packages/package-b/index.js<br>const packageA = require('package-a');<br><br>module.exports = () =&gt; {<br>  packageA();<br>  console.log('Hello from Package B!');<br>};</pre>\n<h3>npm link in Workspaces:</h3>\n<h4><strong>Local Development andÂ Testing:</strong></h4>\n<p>npm link</p>\n<p>is a powerful tool in the npm ecosystem, allowing packages to be symlinked for local development. In the context of npm workspaces, this tool can be used to connect packages within the workspace for seamless local development andÂ testing.</p>\n<h4><strong>Mechanism:</strong></h4>\n<p>npm ensures that when using npm link, the linked package is correctly hoisted to the top-level node_modules directory, maintaining the integrity of the workspace structure. After running the above command, package-a will be symlinked and hoisted to the top-level node_modules, allowing seamless development.</p>\n<pre># Example npm link in workspaces<br>cd packages/package-a<br>npm link<br>cd ../package-b<br>npm link package-a</pre>\n<p>After setting up the structure, running npm install in the root directory installs all dependencies for all packages, linking them where necessary.</p>\n<h3>Helpful Commands for Reference</h3>\n<h4><strong>Installing Workspace Dependencies</strong></h4>\n<p>Install dependencies for all packages defined in the workspace configuration.</p>\n<pre>npm install</pre>\n<h4>Scopes and Private Packages in Workspaces</h4>\n<ul><li>Scopes (@scope/package) can also be used in workspaces, and the logic of private scopes stillÂ applies.</li></ul>\n<pre># Example of installation in workspaces with private scope<br>npm install @scope/package-a --workspace</pre>\n<h4>Listing Dependencies Across Workspaces</h4>\n<p>List dependencies across all workspaces.</p>\n<pre>npm ls</pre>\n<h3>Hoisting in npm Workspaces</h3>\n<p>In npm workspaces, hoisting plays a crucial role in optimizing the installation and management of dependencies across multiple packages within the same workspace.</p>\n<h4>Common Dependencies</h4>\n<ul><li>When multiple packages within a workspace depend on the same package and version, npm hoists that dependency to the top-level node_modules directory. This means that instead of having duplicate copies of the same dependency in each package's node_modules, there's a single shared instance at theÂ root.</li></ul>\n<pre>// Example workspace package.json<br>{<br>  \"workspaces\": [\"packages/*\"],<br>  \"dependencies\": {<br>    \"lodash\": \"^4.17.21\"<br>  }<br>}</pre>\n<p>If two packages within the workspace use lodash, npm ensures that only one copy of lodash is present at the top-level node_modules directory.</p>\n<h4>Scoped Packages</h4>\n<ul><li>For scoped packages, hoisting also occurs within the scoped directory, further optimizing the organization of dependencies.</li></ul>\n<pre>// Example workspace package.json with scoped package<br>{<br>  \"workspaces\": [\"packages/*\"],<br>  \"dependencies\": {<br>    \"@my-monorepo/package-a\": \"^1.0.0\"<br>  }<br>}</pre>\n<p>The scoped package, in this case, will be hoisted to the top-level node_modules/@my-scope/package-a directory.</p>\n<h3>Benefits of Hoisting in npm Workspaces:</h3>\n<p><strong>Disk Space Efficiency</strong></p>\n<p>By hoisting common dependencies, npm workspaces optimize disk space usage, as thereâ€™s only one copy of a dependency shared among multiple packages.</p>\n<p><strong>Faster Installations</strong></p>\n<p>Hoisting reduces the time it takes to install dependencies, as npm can avoid redundant installations and copy operations.</p>\n<p><strong>Consistent Dependency Versions:</strong></p>\n<p>Hoisting ensures that all packages within the workspace use the same version of a dependency, avoiding version conflicts.</p>\n<h3>Conclusion</h3>\n<p>While it is feasible to manage tasks at the individual workspace level, centralizing shared responsibilities at the root level fosters a more coherent and straightforward approach. Embracing npm Workspaces can significantly improve monorepo management, fostering enhanced collaboration, modularity, and overall development efficiency. However, the choice between npm Workspaces, Yarn Workspaces, and Yarn Berry hinges on considerations such as ecosystem familiarity, project requirements, and personal preferences. Each of these tools possesses unique strengths, and the decision should be carefully aligned with the specific needs and objectives of theÂ project.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ce0cdfe1c625\" width=\"1\" height=\"1\" alt=\"\">\n",
			"content": "\n<h3>A little about current workspace managers</h3>\n<a href=\"https://medium.com/media/86b9287d3e6c7c18976c8b8921174338/href\">https://medium.com/media/86b9287d3e6c7c18976c8b8921174338/href</a><h4>Yarn Classic x Yarn Berry Workspaces</h4>\n<p><strong>Dependency Resolution:</strong> Yarn classic workspaces use a â€œpluggableâ€ resolution algorithm, providing more flexibility in how dependencies are resolved. Like npm, Yarn uses hoisting to share common dependencies at the root level, unlike Yarn Berry, which has a new architecture with a â€œplugâ€™nâ€™playâ€ resolution strategy, aiming for a zero-installation approach. It takes advantage of the concept of â€œPnPâ€ files to represent dependencies without the need for a traditional node_modules directory. This is a complex choice if you want to migrate managers later because Yarn Berry eliminates the need for a central node_modules leading to faster and more efficient installations however brings significant changes in how dependencies are resolved.</p>\n<h4><strong>Npm Workspaces</strong></h4>\n<p><strong>Dependency Resolution: </strong>npm workspaces utilize a â€œfixedâ€ strategy for dependency resolution. Each workspace has its own node_modules, and dependencies are installed per workspace. However, common dependencies are hoisted to the root node_modules to optimize diskÂ space.</p>\n<p><strong>Established Ecosystem Integration:</strong> Being the default package manager for Node.js, npm seamlessly integrates with the broader Node.js ecosystem.</p>\n<p><strong>Share Dependencies: </strong>npm Workspaces enable the sharing of dependencies between packages. If multiple packages require the same dependency, it can be installed once at the workspace level, optimizing disk space and simplifying dependency management.</p>\n<h3>Hands-on with npm workspace</h3>\n<h4>Setup Project</h4>\n<pre>mkdir your-project &amp;&amp; cd your-project &amp;&amp; npm init -y</pre>\n<h4>Parent Workspace Configuration (root package.json)</h4>\n<pre>{<br>  \"name\": \"my-monorepo\",<br>  \"workspaces\": [<br>    \"packages/*\"<br>  ],<br>// Example of shared scripts in workspaces<br>{<br>  \"scripts\": {<br>    \"build\": \"npm run build:package-a &amp;&amp; npm run build:package-b\",<br>    \"build:package-a\": \"cd packages/package-a &amp;&amp; npm run build\",<br>    \"build:package-b\": \"cd packages/package-b &amp;&amp; npm run build\"<br>  }<br>}<br>}</pre>\n<h4>Directory Structure</h4>\n<pre>/my-monorepo<br>|-- /packages<br>|   |-- /package-a<br>|   |-- /package-b<br>|-- package.json</pre>\n<h4>Package A</h4>\n<pre>// /packages/package-a/package.json<br>{<br>  \"name\": \"package-a\",<br>  \"version\": \"1.0.0\",<br>  \"main\": \"index.js\",<br>  \"scripts\": {<br>    \"test\": \"echo \\\"Error: run tests from root\\\" &amp;&amp; exit 1\"<br>  }<br>}</pre>\n<pre>// /packages/package-a/index.js<br>module.exports = () =&gt; {<br>  console.log('Hello from Package A!');<br>};</pre>\n<h4>Package B</h4>\n<pre>// /packages/package-b/package.json<br>{<br>  \"name\": \"package-b\",<br>  \"version\": \"1.0.0\",<br>  \"main\": \"index.js\",<br>  \"dependencies\": {<br>    \"package-a\": \"1.0.0\"<br>  },<br>  \"scripts\": {<br>    \"test\": \"echo \\\"Error: run tests from root\\\" &amp;&amp; exit 1\"<br>  }<br>}</pre>\n<pre>// /packages/package-b/index.js<br>const packageA = require('package-a');<br><br>module.exports = () =&gt; {<br>  packageA();<br>  console.log('Hello from Package B!');<br>};</pre>\n<h3>npm link in Workspaces:</h3>\n<h4><strong>Local Development andÂ Testing:</strong></h4>\n<p>npm link</p>\n<p>is a powerful tool in the npm ecosystem, allowing packages to be symlinked for local development. In the context of npm workspaces, this tool can be used to connect packages within the workspace for seamless local development andÂ testing.</p>\n<h4><strong>Mechanism:</strong></h4>\n<p>npm ensures that when using npm link, the linked package is correctly hoisted to the top-level node_modules directory, maintaining the integrity of the workspace structure. After running the above command, package-a will be symlinked and hoisted to the top-level node_modules, allowing seamless development.</p>\n<pre># Example npm link in workspaces<br>cd packages/package-a<br>npm link<br>cd ../package-b<br>npm link package-a</pre>\n<p>After setting up the structure, running npm install in the root directory installs all dependencies for all packages, linking them where necessary.</p>\n<h3>Helpful Commands for Reference</h3>\n<h4><strong>Installing Workspace Dependencies</strong></h4>\n<p>Install dependencies for all packages defined in the workspace configuration.</p>\n<pre>npm install</pre>\n<h4>Scopes and Private Packages in Workspaces</h4>\n<ul><li>Scopes (@scope/package) can also be used in workspaces, and the logic of private scopes stillÂ applies.</li></ul>\n<pre># Example of installation in workspaces with private scope<br>npm install @scope/package-a --workspace</pre>\n<h4>Listing Dependencies Across Workspaces</h4>\n<p>List dependencies across all workspaces.</p>\n<pre>npm ls</pre>\n<h3>Hoisting in npm Workspaces</h3>\n<p>In npm workspaces, hoisting plays a crucial role in optimizing the installation and management of dependencies across multiple packages within the same workspace.</p>\n<h4>Common Dependencies</h4>\n<ul><li>When multiple packages within a workspace depend on the same package and version, npm hoists that dependency to the top-level node_modules directory. This means that instead of having duplicate copies of the same dependency in each package's node_modules, there's a single shared instance at theÂ root.</li></ul>\n<pre>// Example workspace package.json<br>{<br>  \"workspaces\": [\"packages/*\"],<br>  \"dependencies\": {<br>    \"lodash\": \"^4.17.21\"<br>  }<br>}</pre>\n<p>If two packages within the workspace use lodash, npm ensures that only one copy of lodash is present at the top-level node_modules directory.</p>\n<h4>Scoped Packages</h4>\n<ul><li>For scoped packages, hoisting also occurs within the scoped directory, further optimizing the organization of dependencies.</li></ul>\n<pre>// Example workspace package.json with scoped package<br>{<br>  \"workspaces\": [\"packages/*\"],<br>  \"dependencies\": {<br>    \"@my-monorepo/package-a\": \"^1.0.0\"<br>  }<br>}</pre>\n<p>The scoped package, in this case, will be hoisted to the top-level node_modules/@my-scope/package-a directory.</p>\n<h3>Benefits of Hoisting in npm Workspaces:</h3>\n<p><strong>Disk Space Efficiency</strong></p>\n<p>By hoisting common dependencies, npm workspaces optimize disk space usage, as thereâ€™s only one copy of a dependency shared among multiple packages.</p>\n<p><strong>Faster Installations</strong></p>\n<p>Hoisting reduces the time it takes to install dependencies, as npm can avoid redundant installations and copy operations.</p>\n<p><strong>Consistent Dependency Versions:</strong></p>\n<p>Hoisting ensures that all packages within the workspace use the same version of a dependency, avoiding version conflicts.</p>\n<h3>Conclusion</h3>\n<p>While it is feasible to manage tasks at the individual workspace level, centralizing shared responsibilities at the root level fosters a more coherent and straightforward approach. Embracing npm Workspaces can significantly improve monorepo management, fostering enhanced collaboration, modularity, and overall development efficiency. However, the choice between npm Workspaces, Yarn Workspaces, and Yarn Berry hinges on considerations such as ecosystem familiarity, project requirements, and personal preferences. Each of these tools possesses unique strengths, and the decision should be carefully aligned with the specific needs and objectives of theÂ project.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ce0cdfe1c625\" width=\"1\" height=\"1\" alt=\"\">\n",
			"enclosure": {},
			"categories": []
		}
	]
}